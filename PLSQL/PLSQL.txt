============== PLSQL =================

Q.. What is Trigger?
==> Trigger is stored procedure in Oracle that automatically executed or fired
	when a specific event occur on a table,view or database.
----------------------------------------
Q.. What is mean by stored procedure?
==> - When we execute SQL query then internally 
      SQL query get Parsed=>Compiled=>Executed
	- IF we execute same query multiple time then every time 
	  query get Parsed,Compiled and executed.
	- Stored procedure means A precompiled and stored SQL program inside the database
	  can be executed repeatedly.
----------------------------------------
Q.. Usage or Purpose of Trigger?
==> It is used for 
	1. Data Validation.
	2. Enforcing business rules.
	3. Auding changes or deriving values.
----------------------------------------
Q.. Types of trigger?
==> Triggers are classified based on Event Type,Timing,Scope(level)
	
	A) Based on Event Type: 
		1. DML Trigger
			The trigger which fired on DML operation is called DML Trigger 
			DML operations are INSERT,UPDATE,DELETE.
		
		2. DDL Trigger: 
			The trigger which fired on DDL operation is called DDL Trigger 
			DDL operations are CREATE,ALTER,DROP
		
		3. Database event trigger or System event triggers
			The trigger which perform on database event is called database event trigger 
			for e.g => LOGON,LOGOFF,STARTUP,SHUTDOWN.
			
	B) Based on Timing
		1. Before Trigger: fires before the DML event 
		2. After Trigger: fires after the DML event 
		
	C) Based on Scope(level)
		1. Statement level trigger- Fire once per statement 
		2. Row level trigger - fire once per row affected 
		
	D) Other Special types Not seperate categories 
		1. Instead of trigger 
			It is special type of trigger 
			It is applicable only for views 
			Used when view are not directly updatable 
			
		2. Compound Trigger 
			It is special case of row/statement trigger 
			combines all four timing points 
			BEFORE ROW 
			AFTER ROW 
			BEFORE STATEMENT
			AFTER STATEMENT
----------------------------------------
Q.. Syntax of DML Trigger?
==> CREATE [OR REPLACE] TRIGGER Trigger_name 
	{BEFORE | AFTER | INSTEAD OF}
	{INSERT | UPDATE [OF clm1,clm3...N] | DELETE }
	ON table_name_or_view_name 
	[FOR EACH ROW]
	[WHEN (condition)]
	DECLARE 
		-- optional : variable declartion
	BEGIN
		-- trigger logic 
	EXCEPTION
		-- optional: error handling 
	END;
	/
	
	
	here 
		The portion mentioned in [] is optional part 
		so in above syntax: 
			OR REPLACE
			OF clm1,clm2
			FOR EACH ROW 
			WHEN(condition)
		are the optional parameter.
		
		1. FOR EACH ROW : 
			- it is optional part 
			- FOR EACH ROW means it is row-level trigger 
			- FOR EACH ROW means trigger will execute once for each row affected by the DML statement 
			- If we don't use FOR EACH ROW then trigger become statement level trigger 
			- statement level trigger fire once no matter how many rows affected
			
		2. DECLARE
			- it is used to declare the variable,constant and cursor declartion.
			
		3. BEGIN ... END
			- BEGIN section is mandatory and it is called as trigger body 
			- it is executable part 
			- it contains executable logic for the trigger 
			- every BEGIN block must be end with "END"
			- We can write multiple BEGIN and END block for one trigger 
			
		4. EXCEPTION
			- EXCEPTION is used to write error handling code 
			- It is optional block but recommended 
			
		/ => it is end of CREATE TRIGGER BLOCK
------------------------------------	
Q.. Which statement are allowed in trigger body?
==> allowed statements are INSERT,UPDATE,DELETE,SELECT
------------------------------------	
Q.. Which statements are not allowed in trigger body?
==> CREATE,DROP,ALTER,COMMIT,ROLLBACK
------------------------------------
Q.. Consider Employee table when a row is inserted into Employee table 
	then insert a record into audit_log table.
==> CREATE trigger employee_tgr 
	After INSERT on employee 
	FOR EACH ROW 
	Begin
		INSERT INTO audit_log(LOG_ID,MSG,INSERT_DATE,USER_NAME) values(audit_log_sequence.nextval,'data added',sysdate,'yash');
	END 
	/
------------------------------------
Q.. Can we write TCL(COMMIT,ROLLBACK,SAVEPOINT) statement in trigger body?
==> If we write TCL statements in trigger,trigger is created,we don't get any error 
	but at the time of execution it give an error
	so,final conslusion is TCL statements are not allowed in the trigger body.
------------------------------------
Q.. If trigger body insert data into table,how will that data get committed if
	COMMIT is not allowed in Trigger?
==> The COMMIT operation is done by session that fired the trigger not by trigger itself
------------------------------------
Q.. If trigger body is performing DML operation,how will that data get committed 
	if COMMIT is not allowed in Tigger?
==> The COMMIT operation is done by the session that fired the trigger not by trigger itself			
------------------------------------
Q.. What is RAISE_APPLICATION_ERROR in oracle?
==> - RAISE_APPLICATION_ERROR is build in procedure
	- it is used to generate custom error message in PLSQL
	- we can use this procedure in trigger,procedure or function
	- This is useful when you want to enforce business rule or 
	  inform users of specific problem 
	- Syntax:
		RAISE_APPLICATION_ERROR(error_number,message [,{true | false}]);
	- It accept 3 input arguments first input argument is error number,
	  second input argument is error message,third argument is True or False value.
	
	1. error_number: A negative integer between -20000 to -20999 used as the error code.
	
	2. message: A string message explaining the error (max 2048 character)
	
	3. TRUE | FALSE: It is optional.TRUE propogate the error to the client
	   FALSE log it but does not propogate it.
------------------------------------
Q.. What happen if we use error number is out of range in RAISE_APPLICATION_ERROR?
==> we will get an error 
	ORA-21000: error number argument raise_application_error of 1000 is out of range 
------------------------------------
Q.. What happen if we use predefined error code in RAISE_APPLICATION_ERROR?
==> we will get an error 
	ORA-21000: error number argument raise_application_error of 06502 is out of range 
------------------------------------
Q.. What is PL/SQL block?
==> It is structured way of writing Pl/SQL code 
	It consist of three sections: declartion section,
	executable section and the exception handling section
	
	- Syntax: 
		DECLARE
			-- declare the variable // this is optional 
		BEGIN
			-- executable section 
			-- it is mandatory section 
		EXCEPTION
			--Error/EXCEPTION handling section
			-- it is optional 
		END;
------------------------------------
Q.. Types of PL/SQL block?
==> PL/SQL block can be IMPLICIT or EXPLICIT 
	Implicit means created by oracle 
	Explicit means create by developer 
	Explicit block can be anonymous block or named block 
	
	1. Implicit: 
		- Automatically created by oracle engine
		- we cannot see these blocks 
		- example: 
			1. Each SQL statement run in an implicit PL/SQL block 
			2. Exception like no_data_found are raised automatically
			
	2. Explicit: 
		- Block written by developer is called explicit block 
		- Developer can control the structure 
		- Explicit block are 2 types 
			1. Anonymous block 
			2. Named block 
			
			1. Anonymous block: 
				- block without name is called Anonymous block
				=> Properties 
					- it is nameless 
					- Anonymous block is not stored in the database 
					- It is used for quick testing 
					- Execute immediately 
					- cannot be called again 
				=> Structure 
					DECLARE
						-variable declaration 
					BEGIN
						--executable statement 
					EXCEPTION
						--optional 
						--exception handlers 
					END;
			
			2. Named block : 
				- The block which has name is called Named block 
				=> properties 
					- named block is stored in the database 
					- it can be reused 
				=> Types of named block 
					1. Procedures 
					2. Function
					3. Trigger
					4. Packages
------------------------------------
Q.. What is the purpose of / in PL/SQL?
==> / is used to execute block in SQL plus or SQL developer
------------------------------------
Q.. Nesting of PL/SQL block?
==> Nesting of block in PL/SQL means placing one block inside another block
	
	=> Example: 
		DECLARE 
		-- variable declaration for outer block 
		BEGIN
		-- outer block BEGIN
			DECLARE 
			-- inner block declare section 
			BEGIN
			-- inner block begin section
			END;--end of inner block 
		END;--end of outer block 
		
	- Block statements are executed from top to bottom.
	- Inner block can have its own DECLARE section 
	- Variables in inner block are local to that block 
	- Outer block variable can be used in inner block but 
	  inner block variable can't be used in outer block 
	- Same variable we can declare in inner block 
	

------------------------------------
Q.. What is mean by variable?
==> Variables are placeholder which hold value temporary the execution of PL/SQL block.
------------------------------------
Q.. Where do we declare variable?
==> A variable must be declare inside the DECLARE section of PL/SQL block.
	Syntax: 
		variable_name data_type [not null] [:=initial_value]
	
	not null => means variable not hold null value at any time 
	
	RULE FOR NAMING PL/SQL VARIABLE: 
	1. If you declare variable with NOT NULL,you must initilize variable at the time 
	   of declaration,otherwise we will get an error 
	2. If you delcare variable with NOT NULL and later you assign value to variable then 
	   oracle engine raise an exception.
	3. Variable name can be combination of uppercase character,lowercase character,digit
	   and special symbols underscore(_),doller($),hashtag(#).
	4. Variable name must be start with letter.
	5. Variable name should not be start with number or special symbol.
	6. Keywords are not allowed for variable name.
	7. Blank space is not allowed in variable name.
	8. maximum length of variable is 30 character
	9. Variable names are not case sensitive
------------------------------------
Q.. Initilization of Variable?
==> Initilization means assigning value to variable
	- we can Initilize variable using 2 ways
		1. using assignment operator (:=)
		2. using DEFAULT keyword
	- we can Initilize variable at the time of declaration or after the declaration. 
	- If we declare variable then we can Initilize only in BEGIN section 
	  otherwise we will get an error 
	- If we want to initilize variable after the declartion inside the BEGIN section 
	  then we need to use (:=) operator,if we use DEFAULT then we will get an error.
------------------------------------
Q.. Classification of Variable?
==> 1. Data type based variable
	2. Scope based variable
------------------------------------
Q.. Classification based on Data type?
==> Data type based variable means which type of value hold by variable 
	we have below types 
	1. Scalar variables
	2. Composite variables
	3. Reference Variable
	4. LOB Variable
------------------------------------
Q.. What is mean by scalar variable?
==> The variable which hold single value at a time is know as scalar variable 
	- scalar variables are also called as atomic variables or single valued variables 
------------------------------------
Q.. What is mean by Composite variable?
==> The variable which hold multiple value at a time is called as Composite variable.
------------------------------------
Q.. What is Reference variable?
==> The variable which hold reference of another variable is called Reference variable.
------------------------------------
Q.. What is mean by LOB variable?
==> The variable which hold large object are called LOB variable.
------------------------------------
Q.. Classification based on scope of variable?
==> Scope of variable means where the variable can be accessible.
	1. Local variable
	2. Global variable 
	3. Formal parameters
	4. Bind variable
------------------------------------
Q.. What is Local variable?
==> The variable declared inside block is nothing but local variable 
	- Local variable can be used within that block 
	- Outside the block they are not accessible
	- If we have nexted block then outer block variable can be accessible inside inner block
	  but inner block variable not accessible inside outer block 
------------------------------------
Q.. What is Global variable?
==> The variable declared inside package specification is called global variable.
	- Global variable are accessible to all procedures/functions inside the package
------------------------------------
Q.. What is Formal Parameter?
==> Variable declared inside procedure/functions as a parameter are called as Formal Parameter
	- Formal parameter are accessible any where within that procedure/functions.
------------------------------------
Q.. What is Bind Variable?
==> A variable whose value is supplied at execution time and bound to 
    SQL statement is called bind variable
	==> How to declare bind variable 
		- Bind variable not declared inside PL/SQL DECLARE section 
		- They are declared at the client tool level,using syntax 
		  VARIABLE var_name data_type;
		  Example: 
		  VARIABLE v_empname VARCHAR(100);
		  
		- How to assign value to variable 
			1. Syntax for EXEC 
			EXEC :variable_name :=value;
			Example
			EXEC :variable_name :=value;
		    
			2. Syntax for Begin...End
			BEGIN
			:variable_name:=value;
			END;
			/
------------------------------------
Q.. What is Scope of Bind variable?
==> Bind variables have SESSION scope - they exist and remain 
	accessible as long as your database session is active.
------------------------------------
Q.. Why it is called Bind?
==> Because of value is bound (attached) to the SQL statement during execution
	- Databse parses the SQL only once and later you can send new values without parsing again 
------------------------------------
Q.. can we declare bind variable inside DECLARE section?
==> No - we cannot declare bind variable inside DECLARE section.
------------------------------------
Q.. PL/SQL Anchored data types : %TYPE and %ROWTYPE
==> Anchored data types link a varaibles data type to a database column or table row 
	so if the table changes,your PL/SQL code does not break.
------------------------------------
Q.. What is %TYPE 
==>	- If we want to store column types value then use %TYPE 
	- %TYPE allows PL/SQL variable to inherit the data type and size of a table column 
	- Benefit: If column data type changed then no need change PL/SQL code.
	- How to declare variable of %TYPE 
		Syntax: 
		variable_name table_name.column_name%TYPE 
		
		e.g 
			DECLARE 
			v_empname emp11.emp_name%TYPE;
			BEGIN
			 select emp_name into v_empname from emp11 where emp_id=101;
			 dbms_output.put_line(v_empname);
			END;
			/
			
	- If we want to store column value then use %TYPE 
------------------------------------
Q.. How many value %TYPE variable holds?
==> only one at a time 
------------------------------------
Q.. Does %TYPE store multiple rows or values?
==> No
------------------------------------
Q.. What does %TYPE do?
==> It copies datatype,size,precision,scale.
------------------------------------
Q.. What is %ROWTYPE?
==> %ROWTYPE allows variable to hold entire row of table or cursor.
	- %ROWTYPE always store all column 
	- We can't use %ROWTYPE to store perticular column
	How to declare %ROWTYPE
	 variable_name table_name%ROWTYPE
	 
	Exmple:
		DECLARE
		v_emprow emp11%ROWTYPE;
		BEGIN
		 select * into v_emprow from emp11 where emp_id=101;
		 dbms_output.put_line(v_emprow.emp_id || v_emprow.emp_name || v_emprow.salary);
		END;
		/
------------------------------------
Q.. What is Substitution variable?
==> Substitution variable is variable start with & or && and allows user to pass input at run time
	- Substitution varaible is used to get input from user at runtime 
	- They are not PL/SQL variables,but used in Oracle client tools like SQL Plus,SQL Developer.
	Syntax: 
		&variable_name 
		&&variable_name
------------------------------------
Q.. What is difference between '&variable_name' and '&&variable_name'?
==> &variable_name : Prompt every time(ask every time)
	&&variable_name: Prompt one time and store that value and reuse.
------------------------------------
Q.. What is CONSTANT Variable?
==> Variable whose value cannot be changed once it is assigned is nothing but CONSTANT variable.
	- it is useful for fixed values such as tax rates,PI,maximum limit or any value that 
	  should not change during execution.
	- Syntax: 
		Variable_name CONSTANT datatype :=value;
------------------------------------
Q.. NOT NULL is constraint in PLSQL?
==> In PL/SQL variables,NOT NULL is not a constraint,but a variable attribute.
	- It behave like a constraint,but it is not a database constraint.
------------------------------------
Q.. If we don't initilize variable then what is its default value?
==> default value of variable is null.
------------------------------------
Q.. What happen if we declare variable twice in same block?
==> - if we declare variable twice and not Initilize it then we don't get any error 
	- if we declare variable twice and Initilize it then we will get an error.
------------------------------------
Q.. Can we access outer block variable inside inner block?
==> Yes we can access 
------------------------------------
Q.. Can we access Inner block variable inside outer block?
==> No 
------------------------------------
Q.. When is a variable created in PL/SQL?
==> Variable created At the time of block execution.
------------------------------------
Q.. When is a variable destroyed in PL/SQL?
==> Ones block execution is completed then a variable destroyed from the memory.
------------------------------------
Q.. What is data type in PL/SQL?
==> which type of value store in variable is nothing but data type.
------------------------------------
Q.. Type of data type in PL/SQL?
==> 1. Scalar data type 
	2. Composite data type 
	3. Reference data type 
	4. LOB data type 
------------------------------------
Q.. Scalar data type?
==> - The data type which store single value at a time is called scalar data type.
	- Scalar data type is divided into different types 
		1. Numeric 
			- Number
			- PLS_Integer 
			- binary_float 
			- binary_double 
			
		2. Character
			- CHAR 
			- NCHAR 
			- VARCHAR2 
			- NVARCHAR2
			
		3. Date & Time 
			- DATE 
			- TIMESTAMP
			
		4. Boolean
			- BOOLEAN 
------------------------------------
Q.. NUMERIC 
==> 1. NUMBER:
	- It is used to store exact numeric value,including integer and fractional numbers.
	- Syntax:
		NUMBER(p,s)
		p:P stand for Precision.Precision means Total number of digit.
		s:S stand for Scale.Scale means Digits after decimal point 
	- Range of Precision is 1 to 38 and Range of scale is -84 to +127
	
	2. PLS_Integer
	- It is PL/SQL specific scale numeric data type.
	- It store only integer values.
	- If we assign decimal value then we will not getting any error.it will ignore 
	  decimal part and consider only integer.
	- It is fastest integer data type than number,binary_double,binary_float 
	  because it perform arithmatic operation at CPU-level
	- Its size 4 byte (32bit)
	- Range -2,147,483,648 to +2,147,483,647
	- If value exceed then we will get an error "numeric overflow"
	
	=> Where to use PLS_Integer
		1. Loop counters 
		2. Array Indexes 
		3. High performance numeric calculations 
		
	3. Binary_Float
	- It is 32 bit(4 byte),single precision floating point numeric data type.
	- 32 bit means it store 32 bit floating point number. 
	- It store approximately 6-7 decimal digit
	- It is faster than Number.
	- It is designed for high performance and scientific calculations, not exact precision.
	- It follows IEEE 754 single-precision floating point format.
	- Range 
		minimum positive value=> 1.175*10^-38
		maximum positive value=> 3.402*10^38
		
		
	4. Binary_Double
	- It is 64 bit (8-byte),double precision floating point numeric data type.
	- 64 bit (8byte) means it store 64 bit floating point number.
	- It is used when you need high speed numeric calculations with higher precision
	  than Binary_Float.
	- It stores approximately 15 to 17 decimal digit 
	- It provide more accurancy than Binary_Float
	- It follows IEEE-754 double-precision floating point format 
	- Range 
		Binary_Double store extremely large value (up to 10^308) and extremely small (down to 10^-324)
		with ~15-17 digit accurancy 
		
------------------------------------
Q.. IEEE-754 standard?
==> - Arithmatic calculations of floating point may vary from system to system 
	- so to overcome this problem IEEE created an international standard for floating-point 
	  arithmatic calculations and that standard is know as IEEE-754 standard 
	- Every floating-point arithmatic calculation has to follow IEEE-754 standard 
	  so as to get platform independent or machine independent result.
	- IEEE stands for Institute of Electrical and Electronics Engineers.
------------------------------------
Q.. Character Scalar Data Type?
==> 1. CHAR
	- Char stand for character 
	- it is fixed in length 
	- maximum size of char is 32,767 bytes 
	- default size is 1. 
	
	2. NCHAR
	- NCHAR stand for National Character
	- It is fixed length Unicode character data type in oracle.
	- It is used to store national character set data,which supports multiple languages
	  (like Hindi,Chinese,Arabic,etc)
	- PL/SQL min size for NCHAR is 1
	- SQL min size for NCHAR is 1 
	- PL/SQL max size for NCHAR is 32767 bytes 
	- SQL min size for NCHAR is 2000 bytes 
	- Default size of NCHAR is 1. 
	
	3. VARCHAR2
	- It is variable length character data type.
	- Variable means memory adjusted depending on actual string length.
	- PL/SQL max size of VARCHAR2 is 32767
	- SQL max size of VARCHAR2 is 4000.
	
	4. NVARCHAR2
	- NVARCHAR2 is variable length unicode character data type in oracle.
	- It store multi language string in the national character set.
	- PL/SQL max size is 32676 character.
	- SQL max size of NVARCHAR2 is 4000.
------------------------------------
Q.. What is difference between CHAR and NCHAR?
==> - CHAR stand for character where as NCHAR stand for National character
	- CHAR uses the database character where as NCHAR uses National character set 
	- CHAR uses minimum 1 byte per character where as NCHAR uses 2 byte per character.
	- CHAR may support Unicode depending on the database character set where as 
	  NCHAR always store Unicode data 
	- CHAR is typically used for English or single-byte character where as 
	  NCHAR is used for multilingual data
	- CHAR generally uses less storage where as NCHAR uses more storage.
	- CHAR is faster than NCHAR because it involves simpler encoding.
------------------------------------
Q.. Why there is size difference in SQL and PL/SQL?
==> SQL has smaller limits because data stored in tables.
	PL/SQL allows larger sizes because data is stored in memory only 
------------------------------------
Q.. What is mean by database character set?
==> Normal english set
------------------------------------
Q.. What is mean by National character set?
==> Multilingual/unicode text
------------------------------------
Q.. What is difference between VARCHAR2 and NVARCHAR2?
==> - VARCHAR2 stand for Variable length character data where as 
	  NVARCHAR2 stand for National Variable length character data 
	- VARCHAR2 uses database character set where as 
	  NVARCHAR2 uses National character set 
	- VARCHAR2 may support unicode character depending upon database character set where as 
	  NVARCHAR2 always support unicode character
	- VARCHAR2 uses less memory than NVARCHAR2
	- VARCHAR2 uses less disk space than NVARCHAR2
	- VARCHAR2 has better performance than NVARCHAR2
------------------------------------
Q.. In which use case would you choose each data type?
==> Number => use for exact number
	PLS_Integer => for fast integer operation
	Binary_Float => floating point calculation with less accurancy
	Binary_Double => floating point calculation with more accurancy
	CHAR => for fixed length database character set 
	NCHAR => For fixed length unicode character set 
	VARCHAR2 => for variable length database character set 
	NVARCHAR2 => for variable length unicode character set 
------------------------------------
Q.. Performance wise Order (Fast to slow) & Why?
		1. PLS_Integer
		2. Binary_Float
		3. Binary_Double
		4. Number
==> 1. PLS_Integer : directly processed by CPU and no conversion is required so it is fast 
	2. Binary_Float: 32 bit floating point number,small size,Less CPU work required
	3. Binary_Double: 64 bit floating point number,large size,more CPU work required
	
------------------------------------
Q.. COMPOSITE data type?
==> Composite data types are used to store multiple values in a single variable 
	1. RECORD 
	2. TABLE 
	3. NESTED TABLE 
	4. VARRAY
------------------------------------
Q.. REFERENCE data type?
==> REFERENCE data types are used to store memory addresss or pointers 
	1. REF CURSOR 
	2. CURSOR
------------------------------------
Q.. LOB(Large Object) Data types?
==> LOB Data types are used to imges,files,etc.
	1. BLOB(Binary Large Object)
	2. CLOB(Character Large Object)
	3. NCLOB(National Character Large Object)
	4. BFILE(Binary File stored outside database(OS File))
------------------------------------
Q.. What is Conditional statement in PL/SQL?
==> We have 2 type of conditional statements
	1. If statement
	2. Case expression
	- Case expression is used in SQL and PL/SQL but If statement is used only in PL/SQL
	- We can't use IF statement in SQL.
------------------------------------
Q.. IF statement?
==> - IF statement has 3 form 
	1. IF...THEN 
		IF condition THEN 
		statement1;
		statement2;
		.
		.
		statementN;
		END IF;
		
	2. IF...THEN...ELSE
		IF condition THEN
		statement1;
		statement2;
		.
		.
		statementN;
		ELSE
		statement1;
		statement2;
		.
		.
		statementN;
		END IF;
		
	3. IF...THEN...ELSIF...ELSE
		IF condition THEN 
		.
		.
		ELSIF
		.
		.
		ELSE
		.
		.
		END IF;
------------------------------------
Q.. What is SQL%ROWCOUNT ?
==> SQL%ROWCOUNT is an implicit cursor attribute that tell you: 
	how may rows were affected by the most recent SQL statement 
	(INSERT,UPDATE,DELETE,SELECT INTO)
------------------------------------
Q.. Date data type?
==> DATE is scalar data type in PL/SQL
	- DATE data type store data and time 
	- default date format is DD-MON-YY HH24:MI:SS
	- Even if you don't see time it is always stored.
	- DATE data type uses 7 bytes to store date value.
------------------------------------
Q.. TIMESTAMP data type?
==> TIMESTAMP is scalar data type 
	- it is used to store date and time
	- it is more Precise than DATE 
	- TIMESTAMP uses 11 byte to store value
	- 1 second =1000 miliseconds
	- 1 miliseconds = 1000 microseconds
	- 1 second = 10000 microseconds
	- e.g 
		DELARE
			v_time TIMESTAMP;
		BEGIN
			v_time systimestamp;
			dbms_output.put_line(v_time);
		END;
		/
------------------------------------
Q.. TIMESTAMP WITH TIME ZONE?
==> it is scalar data type 
	- it is used to store date and time with time zone 
	- e.g 
		DELARE
			v_time TIMESTAMP WITH TIME ZONE;
		BEGIN
			v_time systimestamp;
			dbms_output.put_line(v_time);
		END;
		/
------------------------------------
Q.. TIMESTAMP WITH LOCAL TIME ZONE?
==> it is scalar data type 
	- stored in database time,shown in your local time
	- save once globally,display according to user location
	- same data with different display 
	- This data type is best for global application
------------------------------------
Q.. INTERVAL YEAR TO MONTH
==> - it store difference in year and months 
	- difference in year and months 
	- suppose employee experience is 2 year and 3 months 
	  same is represented in INTERVAL YEAR TO MONTH 
	  INTERVAL '2-3' YEAR TO MONTH 
	e.g 
		DECLARE 
		 v_date INTERVAL YEAR TO MONTH;
		BEGIN
		 v_date :=INTERVAL '2-3' YEAR TO MONTH;
		 DBMS_OUTPUT.PUT_LINE(v_date);
		END;
		/
		
	O/P => +02-03
------------------------------------
Q.. INTERVAL DAY TO SECOND
==> it store difference in days,hours,minuts,seconds
	- Task ran for:
		2 days 5 hours 30 minuts 20 seconds.
	- above example can represent in INTERVAL DAY TO SECOND 
		INTERVAL '2 05:30:20' DAY TO SECOND
------------------------------------
Q.. Add one day in today's date?
==> select sysdate+1 from dual
------------------------------------
Q.. Add 2 hours in today's date?
==> select sysdate+2/24 from dual;// add 2 hour in today's date
------------------------------------
Q.. Add 30 min in today's date?
==> select sysdate+30/1440 from dual;
------------------------------------
Q.. Add 30 second in today's date?
==> select sysdate+30/86400 from dual;
------------------------------------
Q.. Add 2 days in today's date using INTERVAL?
==> select systimestamp+INTERVAL '2' DAY from dual;
------------------------------------
Q.. Add 2 hours in today's date using INTERVAL?
==> select systimestamp+INTERVAL '2' HOURS from dual;
------------------------------------
Q.. Add 3hours30minute in today's date?
==> select systimestamp + INTERVAL '3.30' HOURS TO MINUTE from dual;
------------------------------------
Q.. Add 2year6month in today's date?
==> select systimestamp + INTERVAL '2-6' YEAR TO MONTH from dual;
------------------------------------
Q.. NUMTOYMINTERVAL function?
==> NUMTOYMINTERVAL function is used to convert number into INTERVAL 
	Syntax:
		NUMTOYMINTERVAL(number,'YEAR'/'MONTH');
------------------------------------
Q.. CAST function?
==> CAST function is used to convert one data type into another data type
	syntax:
		CAST(source_value as target_date_type);
	e.g 
		select CAST(sysdate as TIMESTAMP) from dual;
------------------------------------
Q.. TO_TIMESTAMP function?
==> TO_TIMESTAMP function is used to convert date formated string into TIMESTAMP
	SYNTAX:
		TO_TIMESTAMP(string);
	e.g
		select TO_TIMESTAMP(sysdate) from dual
------------------------------------
Q.. Case expression?
==> Case expression is an alternative for multiple IF-ELSE statements
	Case expression has 2 type
	1. Simple Case expression 
	2. Searched Case expression
------------------------------------
Q.. What is Simple Case expression?
==> Simple Case Expression compares one expression with multiple values.
	- If we want to compare one expression with multiple values then we go with Simple Case expression.
	Syntax: 
		CASE expression 
		When value1 THEN statement1;
		When value2 THEN statement2;
		ELSE statements;
		END CASE;
------------------------------------
Q.. What is Searched Case?
==> If we have multiple multiple condition then go with Searched Case
	Syntax: 
		CASE 
		When condition1 THEN statement1;
		When condition2 THEN statement2;
		ELSE statement;
		END CASE;
------------------------------------
Q.. Write PL/SQL code to print Day name from Day number?
------------------------------------
Q.. Write PL/SQL code to print salary grade based on salary value?
------------------------------------
Q.. Write PL/SQL block to check voting Eligibility?
------------------------------------
Q.. Write PL/SQL block to check number is Even or ODD?
------------------------------------
Q.. Write PL/SQL block to grade student based on Mark?
------------------------------------
Q.. Difference between Simple case and Searched case?
==> - Simple case compares value where as Searched case evalutes condtion
	- Simple case have single expression where as Searched case have multiple conditions 
	- Simple case does not support operators where as Searched case support operators
------------------------------------
Q.. What is mean by short circuit?
==> Stopping the evalution of a condition as soon as final result is known.
	- In PL/SQL logical operators (AND,OR) uses short circuit evalution
------------------------------------
Q.. Why short circuit important?
==> - Improve Performance
	- Prevent runtime errors 
	- Used in real-time validation logic 
------------------------------------
Q.. What is mean by EXCEPTION?
==> unwanted or unexcepted event that break normal execution flow nothing but exception.
	if execption occure then rest of code is not execute.
------------------------------------
Q.. What is mean by Exception handling?
==> Exception handling means providing alternative way so that rest of code get executed if exception occured.
------------------------------------
Q.. Why exception handling required?
==> WITHOUT EXCEPTION HANDLING
	1. Program get terminated abnormally 
	2. No Chance to recover 
	-> WITH EXCEPTION HANDLING
		1. Error can be caught and managed 
		2. We can provide custom message if there is an exception
		3. Program terminated gracefully 
	-> Exception handling is not mandatory but it is recommended 
------------------------------------
Q.. How to handle exception in PL/SQL?
==> To handle exception we use EXCEPTION block 
	There is not seperate existence for EXCEPTION block 
	We need to write exception block inside the BEGIN block 
	- Syntax: 
		BEGIN
			statements;
		EXCEPTION
			statements;
		END;
		/
------------------------------------
Q.. Types of Exception?
==> there are 3 types of exceptions
	1. Predefined exceptions
	2. Non-Predefined exceptions
	3. User defined exceptions
------------------------------------
Q.. Predefined Exceptions:
==> The exceptions which are automatically raised by oracle engine with fixed name and 
	error code are called Predefined Exceptions.
	- Properties
	- Predefined exceptions are already declared so we don't need to declare under DECLARE section
	- Predefined exception have fixed name and error code 
	- Oracle engine raise it automatically
	
	- Predefined exceptions 
	1. NO_DATA_FOUND
	
	2. TOO_MANY_ROWS
	
	3. VALUE_ERROR 
		- it is predefined exception
		- error code: ORA-06502
		- When it is raised 
			1. When converting a value from one data type to another data 
			   and conversion is not allowed 
			2. When assigning a string longer than the declared variable length
			3. When assigning a number exceeds the declared precision or scale.
			
	4. INVALID_NUMBER
		- it is predefined exception 
		- error code: ORA-01722
		- It is raised when If we try to convert non-numeric value into number 
		
	5. DUP_VAL_ON_INDEX
		- it is predefined exception
		- error code: ORA-00001
		- It is raise when Unique constraint voilation
		  If we are inserting duplicate values in primary key column or unique key column 
		  
	6. ZERO_DIVIDE
		- it is predefined exception
		- error code: ORA-01476
		- When it is raise: If we are dividing a number by zero
		
	7. INVALID_CURSOR
		- it is predefined exception
		- error code: ORA-01001
		- it is raise : If we are trying to perform illegal operation
		  on cursor then we will get INVALID_CURSOR exception
		  
	8. CURSOR_ALREADY_OPEN
		- it is predefined exception
		- error code: ORA-06511
		- it is raise: If we are trying to open already opened cursor 
		  then we will get CURSOR_ALREADY_OPEN exception
	
	9. ROWTYPE_EXCEPTION
		- it is predefined exception 
		- error code: ORA-06504
		- when it raise: Incompatible %ROWTYPE
		  Happens when the number of column or data types in the SELECT statement
		  does not match the record 
		  
	10. PROGRAM_ERROR
		- it is predefined exception
		- error code: ORA-06501
		- it is occur due to PL/SQL engine problems 
		
	11. STORAGE_ERROR
		- It is prdefined exception
		- error code: ORA-06500
		- if there is memory allocation problem then we will get STORAGE_ERROR exception
		
	12. TIMEOUT_ON_RESOURCE
		- it is predefined exception
		- error code: ORA-00051
		- if request is not completed within required time then we will get TIMEOUT_ON_RESOURCE 
		
	13. LOGIN DENIED 
		- it is predefined exception
		- error code: ORA-01017
		- when it raise: invalid username or password 
		
	14. OTHERS
		- it is predefined exception
		- error code: NA 
		- Purpose: To catch all type of exceptions
------------------------------------
Q.. Non-Predefined exception?
==> The exception raise by oracle engine and have error code but do not have prdefined
    exception name are called Non-Predefined exception.
	- Properties
		1. Oracle raise automatically
		2. They don't have predefined name,but it has an error code 
		3. developer must have declare it and associate it with error code 
			using PRAGMA EXCEPTION_INIT
			
	- example of non-predefined exception
		1. trying to delete a parent row that has child rows 
		2. FOREGIN KEY constrain voilation
		3. table or view does not exist 
		4. unable to extent table 
------------------------------------
Q.. How to handle Non-Predefined exception?
==> we can handle Non-Predefined exception using 2 ways 
	1. using WHEN OTHERS 
	2. PRAGMA EXCEPTION_INIT
	
	1. using OTHERS 
		BEGIN
		 delete from department where dept_id=101;
		WHEN OTHERS THEN
			dbms_output.put_line('child record exist so can't delete parent table record');
		END;
		
	2. using PRAGMA EXCEPTION_INIT
		DECLARE
			fk_voilation EXCEPTION;
			PRAGMA EXCEPTION_INIT(fk_voilation,-2290);
		BEGIN
			delete from department where emp_id=101;
		EXCEPTION
			WHEN fk_voilation THEN 
				dbms_output.put_line('can't delete parent record ');
			WHEN OTHERS THEN 
				dbms_output.put_line('SQLERRM');
		END;
------------------------------------
Q.. What is PRAGMA EXCEPTION_INIT?
==> - it is compiler directive,not a statement 
	- it is used to associate a user declared exception name with oracle error code.
	- it is mainly used to handle non-predefined exception
	- some oracle error have only error code to give meaning full name those error 
	  codes we use PRAGMA EXCEPTION_INIT.
	- can't be used inside BEGIN section,we need to use in declare section.
------------------------------------
Q.. When to use PRAGMA EXCEPTION_INIT?
==> use PRAGMA EXCEPTION_INIT
	- error does not have predefined exception name
	- You know oracle error number 
	- You want specific handling 
	- You want clean,readable,maintainable code.
------------------------------------
Q.. How does PRAGMA EXCEPTION_INIT work?give an example?
==> PRAGMA EXCEPTION_INIT is a compiler directive in PL/SQL.
	It is used to handle Non-Predefined Exception.
	It is used to map Oracle predefined error number with custom exception name.
	
	-> How it is work?
		- When exception is raised,PRAGMA EXCEPTION_INIT map the error number with 
		  custom exception name and jump into exception handler 
	-> Example: 
		DECLARE
		invalid_age EXCEPTION;
		age number:=13;
		PRAGMA EXCEPTION_INIT(invalid_age,-20001);
		BEGIN
		 if age<17 then
		 RAISE_APPLICATION_ERROR(-20001,'invalid_age');
		 end if;
		EXCEPTION
		  WHEN invalid_age THEN
		  dbms_output.put_line(' error');
		END;
		/
------------------------------------
Q.. difference between predefined and non-predefined exception?
==> - predefined exception have predefined name where as non-predefined excpetion don't have name 
	- predefined exception not require to declare where as non-predefined exception developer must declare
------------------------------------
Q.. when to use WHEN OTHERS?
==> use WHEN OTHERS only when : 
	- You don't know exact error code 
	- You must to log or display the error message.
	- You want to ensure the program does not terminate abnormally
------------------------------------
Q.. When to use PRAGMA EXCEPTION_INIT?
==> Use PRAGMA EXCEPTION_INIT
	- The error does not have a predefined exception name.
	- You know the oracle error number 
	- You want specific handling 
	- You want clean,readable,maintainable code.
------------------------------------
Q.. What is user defined exception?
==> The exception which is declared and raised by programmer is nothing but user defined exception.
	- user defined exception is also called as custom exception.
	- Properties
		1. declared by programmer in declare block
		2. raised by programmer using RAISE and RAISE_APPLICATION_ERROR
------------------------------------
Q.. What is RAISE ?
==> RAISE is PL/SQL statement.
	- RAISE is used to explicitly raise a user defined exception
	- RAISE cannot raise directly PREDEFINED exception like NO_DATA_FOUND.
------------------------------------
Q.. What is the difference between Predefined and User-defined exception?
==> - Predefined exception defined by oracle where as user-defined exception defined by Developer
	- predefined exception are raised automatically where as user defined exception raised using 
	  RAISE or RAISE_APPLICATION_ERROR.
	- Predefined exception have predefined name where as user defined exception have user defined name
	- Predefined exception have predefined error code where as user defined exception have 
	  user defined code -20000 to -20999
	- Predefined exception handle system/runtime errors where User-defined exception handle 
	  business validation rules.
------------------------------------
Q.. what is difference between RAISE and RAISE_APPLICATION_ERROR?
==> - RAISE is used to raise user-defined exception and re-raise predefined or non-predefined exception
	  where as 
	  RAISE_APPLICATION_ERROR is used to raise user-defined exception.
	- RAISE does not allow custom error number or message but 
	  RAISE_APPLICATION_ERROR allows custom error number with message	
------------------------------------
Q.. How do we retrive the error number for an exception?
==> we can retrive error number using SQLCODE.
------------------------------------
Q.. How do we retrive the error number and error message for an exception?
==> We can retrive the error number and message using SQLERRM.
------------------------------------
Q.. Can we re-raise exception?
==> Yes we can re-raise an exception
	In exception handler use RAISE clause as below 
		EXCEPTION
			WHEN EXCEPTION_NAME THEN
				RAISE;
------------------------------------
Q.. Explain the order of exception handlers.Why does it matter?
==> - In PL/SQL there is no paren-child relationship for exception
	- Every exception is independent
	- In PL/SQL exception handlers are executed from top to bottom 
	- For generic exception we use "WHEN OTHERS",If we use WHEN OTHERS then it must be 
	  at last,otherwise we will get compilation error
------------------------------------
Q.. What happen if WHEN OTHERS is not the last exception handler?
==> we will get an compilation error.
------------------------------------
Q.. What is difference between SQLCODE and SQLERRM?
==> SQLCODE returns only error number but SQLERRM returns error number and message
------------------------------------
Q.. How to handle exception in PL/SQL?
==> By using exception block we can handle exception in PL/SQL.	
------------------------------------
Q.. What is difference betwen compilation error,runtime error and exception?
==> COMPILATION ERROR: means syntax error and occur at compilation time 
		syntax error means 
		1. missing semicolon,missing comma's
		2. Undeclared variables.
		3. wrong keyword usage
		
	RUNTIME ERROR: Occured during program execution due to poor logic or lack of system resources
		1. Division by zero
		2. Memory issues
		
	RUNTIME EXCEPTION: An exception is a runtime error but we can handle using exception block 
		- division by zero is runtime exception we can handle 
		- if there is memory issues being developer we can't handle 
------------------------------------
Q.. Difference between unhandled runtime error and handled exception?
==> - unhandled runtime error means we have not handled using exception block 
	- handled exception means we have handled using exception block 
------------------------------------
Q.. Give commanly used predefined exception?
==> 1. NO_DATA_FOUND
	2. TOO_MANY_ROWS
	3. INVALID_NUMBER
	4. VALUE_ERROR
	5. STORAGE_ERROR
	6. DUP_VAL_ON_INDEX
	7. ZERO_DIVIDE
	8. INVALID_CURSOR
	9. CURSOR_ALREADY_OPEN
	10. ROWTYPE_MISMATCH
	11. PROGRAM_ERROR
	12. STORAGE_ERROR
	13. TIMEOUT_ON_RESOURCE
	14. LOGIN_DENIED
	15. OTHERS
------------------------------------
Q.. What is the purpose of WHEN OTHERS clause?
==> it is used to catch any type of exception that is not handled by other exception handlers.
------------------------------------
Q.. How do you declare user defined exception?
==> Syntax to define exception is 
	exception_name EXCEPTION 
------------------------------------
Q.. Can we handle multiple exception in single exception block?
==> Yes we can handle multiple exception in single exception block.
------------------------------------
Q.. How do you handle non-predefined execption?
==> We handle non-predefined exception using PRAGMA EXCEPTION_INIT and steps are 
	1. Declare EXCEPTION
	2. Map error code with custome message using PRAGMA EXCEPTION_INIT
	3. Handle it by name in the Exception block
------------------------------------
Q.. Can we RAISE exception manually?
==> Yes,we can raise exception manually by using RAISE or RAISE_APPLICATION_ERROR.
------------------------------------
Q.. What is SQLCODE in PL/SQL?
==> SQLCODE is predefined procedure.
	SQLCODE return the error code of the most recent exception.
		DECLARE
		v_name varchar2(3);
		v_code number;
		BEGIN
		 v_name:= 'peter';
		 dbms_output.put_line(v_name);
		EXCEPTION 
		 WHEN OTHERS THEN 
		 v_code:=SQLCODE;
		 dbms_output.put_line(v_code);
		END;
------------------------------------
Q.. What is SQLERRM?
==> SQLERRM is predefined function in PL/SQL.
	- It return error code and error message associated with the most recent exception.
		DECLARE
		v_name varchar2(3);
		v_code number;
		BEGIN
		 v_name:= 'peter';
		 dbms_output.put_line(v_name);
		EXCEPTION 
		 WHEN OTHERS THEN 
		 dbms_output.put_line(SQLERRM);
		END;
	- it is used for debugging purpose 
	- If you don't know error code and error message then you retrive using SQLERRM
------------------------------------
Q.. Deffering constraint in Oracle?
==> - default status of constraint is enable.
	- constraints are validated by default 
		validated means verifies existing data + new data
	- constraint are not DEFERRABLE by default 
		NOT DEFERRABLE means constraints check occurs immediately 
		after each DML statement.
	- PRIMARY key and UNIQUE key create an Unique Index automatically
	- FOREGIN key constraints are NO CASCADE DELETE bydefault.
	
	1. STATUS column value can be ENABLED or DISABLED,default is ENABLED.
		=> ENABLED means constraint is Active 
		=> DISABLED means constraint is no validation rules applied
	2. DEFERRABLE column value can be NOT DEFERRABLE or DEFERRABLE,default is DEFERRABLE.
		=> Constraint is DEFERRABLE 
		   - You can control when it is checked IMMEDIATE or DEFERRED.
		   - Constraint is temporary bypass.it get applied at the time of commit.
		=> NOT DEFERRABLE 
			- constraint is non deferred.
			- it is always checked immediately
	3. DEFERRED column value can be INITIALLY IMMEDIATE or INITIALLY DEFERRED,default is INITIALLY DEFERRED.
		=> INITIALLY IMMEDIATE
			- Constraint is checked immediately after each SQL statement
		=> INITIALLY DEFERRED
			- Constraint checking is postponed until COMMIT 
			- Validation rules are applied at the time of commit
	4. VALIDATE column value can be VALIDATED or NOT VALIDATED,default is VALIDATED.
		=> VALIDATED 
			- checking existing data + new data 
		=> NOT VALIDATED 
			- Ignore existing data but validate New Data
------------------------------------
Q.. What is Deferring constraint?
==> Deferring constraint means temporary bypass the validation rules of certain constraint 
	until the end of transaction 
	- Deferring constraint is very usefull in 
		1. Complex transaction
		2. Bulk Loads
		3. Parent-child insert/update in any order
------------------------------------
Q.. Which constraints can be deferred?
==> 1. Primary key
	2. Unique key
	3. Foreign key 
	4. Check constraint 
	-> we can't defer not null and default constraint 
------------------------------------
Q.. When we can define Deferrable constraint?
==> We can define deferrable constraints at the time of table creation and 
	after the table creation
------------------------------------
Q.. Default behaviour of Primary key?
==> status => enabled
	deferrable => NOT DEFERRABLE 
	deferred => INITIALLY IMMEDIATE
	validate => VALIDATED
------------------------------------
Q.. Can we change DEFERRABLE to NOT DEFERRABLE or vice-verca?
==> No we can't change it we need to drop constraint and reapply constraint.
------------------------------------
Q.. How to drop constraint?
==> alter table table_name drop constraint constraint_name.
------------------------------------
Q.. Deferring constraint after table creation?
==> We can make defferable after the table creation but we can make it possible 
	first we need to drop constraint and then add constraint using alter option 
	1. Syntax to make DEFERRABLE constraint with INITIALLY DEFERRABLE 
	=> Alter table table_name constraint name_of_constraint constraint_type (column_name)
	   DEFERRABLE INITIALLY DEFERRED;
	   
	2. Syntax to make DEFERRABLE constraint with INITIALLY IMMEDIATE
	=> alter table table_name add constraint name_of_constraint constraint_type(column_name)
	   DEFERRABLE INITIALLY IMMEDIATE
------------------------------------
Q.. Trigger information stored in which view?
==> Trigger information available in below data dictionary view 
	1. user_triggers
	2. all_triggers
	3. dba_triggers
------------------------------------
Q.. What is difference between user_triggers,all_triggers & dba_triggers?
==> 1. user_triggers
		- user_triggers is a view and accessible to all users
		- It display triggers information created by current logged user 

	2. all_triggers
		- all_triggers is a view and accessible to all users 
		- It disaly triggers information created by current logged user and accessible to current user
	3. dba_triggers
		- dba_triggers is a view and accessible only for dba person.
		- it contain all triggers information
------------------------------------
Q.. How to enable or disable triggers?
==> - bydefault triggers are enabled 
	- we can enable or disable triggers 
	- Syntax to DISABLE perticular trigger 
		alter trigger trigger_name disable
	- Syntax to enable perticular trigger	
		alter trigger trigger_name enable 
	- Syntax to disable all triggers
		alter trigger disable all triggers
	- Syntax to enble all triggers 
		alter trigger enable all triggers 
------------------------------------
Q.. How to drop trigger?
==> drop trigger trigger_name
------------------------------------
Q.. What is Mutating table?
==> Mutating Table means at same time two or more operations are happening on table 
	and one of operation is write operation.
	
	Solution of Mutating
	- Use statement-level trigger
	- use compound trigger 
	- use package variables.
------------------------------------
Q.. What is PRAGMA AUTONOMOUS_TRANSACTION?
==> - PRAGMA AUTONOMOUS_TRANSACTION is used in procedure,function,trigger and block.
	- It is used to run procedure,Function,Trigger and block in its own independant transaction,
	  seperate from calling transaction
	- it commonly used for logging and audit tables.
	- If we are using PRAGMA AUTONOMOUS_TRANSACTION then we need to write COMMIT and ROLLBACK explicitly 
------------------------------------
Q.. When to use PRAGMA AUTONOMOUS_TRANSACTION?
==> - error debugging
	- audit logs 
	- debug tracking
------------------------------------
Q.. Where not to use PRAGMA AUTONOMOUS_TRANSACTION?
==> Not recommended for business logic 
------------------------------------
Q.. If trigger are available on table,can we drop table?
==> Yes we can drop table.
------------------------------------
Q.. If table dropped then what happens with triggers,triggers also dropped or persist in the database?
==> When a table is dropped,all triggers defined on the table are automatically dropped by oracle engine.
------------------------------------
Q.. What is advantages of Trigger?
==> - Automate business rule
	- Enforce data integrity
	- Maintain audit history
	- Reduce code in application layer 
	- Automatic logging & validation
------------------------------------
Q.. What is disadvantage of Trigger?
==> - Hard to debug 
	- Hidden login inside database
	- Can cause performance issues if not written properly 
	- Risk of mutating table errors
	- Can create circular trigger dependancies 
------------------------------------
Q.. When should go with Trigger or Constraint?
==> Constraint => data integrity
	Trigger => Complex business logic 
------------------------------------
Q.. What is instead of Trigger?
==> An Instead of trigger is a special type of trigger that fires instead of actual DML operations 
	- it is mainly used with complex views.
	
	Syntax: 
		CREATE OR REPLACE TRIGGER Trigger_name
		INSTEAD OF INSERT ON complex_view_name
		FOR EACH ROW 
		BEGIN
		 insert into table_name values(clm1,clm2,clm3,...N);		
		END;
		/
------------------------------------
Q.. Can we insert INSTEAD of trigger on table?
==> NO
------------------------------------
Q.. Can we use before after in INSTEAD of trigger?
==> NO 
------------------------------------
Q.. Can one INSERT INTO STATEMENT insert data into two tables?
==> YES 
------------------------------------
Q.. sometime delete operation is allowed in complex view but sometime delete operations are not 
	not allowed on complex view,why?
Q.. In which case delete operation is allowed on complex view and in which use case delete 
	operation is not allowed on complex view?
==> Case 1: DELETE OPERATION IS NOT ALLOWED
	- if view defination contains group functions,distinct clause,order by clause
		or deletion affect multiple base tables then direct DELETE operation is not 
		allowed on that view. In that case solution is Instead of Trigger.
	
	Case 2: DELETE OPERATION IS ALLOWED
	- View is based on multiple tables but only one table is actually updatable and 
		no ambiguity in row mapping,delete operation is allowd on that view 
------------------------------------
Q.. DELETE Operation with instead of trigger?
==> Delete on complex view is not allowed directly we can use INSTEAD OF Trigger to delete 
	complex view.INSTEAD OF Trigger defines how deletion should be performed on underlying base tables 
------------------------------------
Q.. Can we delete data from multiple base table on single delete operation?
==> Yes,using INSTEAD OF trigger.
------------------------------------
Q.. 
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
Q.. Oracle storage heirarchy?
==> Database ->Tablespace->DataFiles(Physical)->segment->Extent->Data Block
------------------------------------
Q.. What is Database?
==> it is collection of datafiles,control files and redo log files.
------------------------------------
Q.. What is tablespace?
==> Tablespace is logical storage unit 
	- Tablespace is group of one or more DataFiles.
	- Tablespace act as a container for database objects like table,view,index.
	- Actual data is stored in DataFiles.
	- data files has extention .dbf
	- some of tablespace created automatically during database creation and these tablespace are
		1. System
		2. Sysaux
		3. Temp
		4. Undo
		5. User
	- Tablespace information store in data dictionary view
		1. DBA_TABLESPACES
		2. USER_TABLESPACES
	- When we fire query 
		select * from DBA_TABLESPACES / select * from USER_TABLESPACES
	  then we will get o/p of 
	  1. TABLESPACE: Name of Tablespace 
	  2. Blocksize: size in byte 
	  3. INITIALEXTENT:size of first extent.it is in byte.
	  4. NEXTEXTENT:size of next extent.it is in byte.
	  5. MINEXTENT:minimum extent size.it is in byte.
	  6. MAXEXTENT:Max extent allowed.it's size is in byte 
	  7. PC_INCREASE:Percentage Increase
	  8. STATUS: Status if Tablespace allowed values are 
			OFFLINE-Tablespace is Open 
			ONLINE-Tablespace is closed
			READONLY-Tablespace is readonly 
			READWRITE-We can read and we can write into tablespace
	 10. CONTENT: Type of database
		 PERMENENT: Table,Index
		 UNDO: Tablespace is for undo operation.
	 11. LOGGING: logs are maintained or not 
			values are logging,nologging.
	 12. EXTENT_MANAGEMENT: How extent are managed.
			LOCAL:modern
			DICTIONARY: old/decrepted.
	 13. ALLOCATION TYPE: How extent size decided?
			SYSTEM: Oracle decides
			UNIFORM: fixed size
	 14. PLUGGED_IN: Tablespace is plugable or not
	 15. SEGMENT_SPACE_MANAGEMENT: How the segment space is managed values are MANUAL and AUTO.
------------------------------------
Q.. If we don't specify tablespace while creating a table,table get created in default tablespace.
	If default tablespace is SYSTEM then table is created in SYSTEM table.
	- If we want to cross check your table space then use below query 
		select * from user_tables where table_name ='table_name';
	- we can explicitly specify the tablespace 
		create table table_name(....)TABLESPACE name_of_tablespace;
	- Note: It is not recommended to use SYSTEM tablespace,SYSAUX tablespace,UNDO tablespace 
	  or TEMP tablespace to store user objects 
	- Always use USER tablespace or custom tablespace to store user objects 
	
------------------------------------
Q.. Types of Tablespace?
==> 1. System
		- it is heart of oracle database.
		- It is manadatory tablespace and created during DB creation.
		- We can't drop this tablespace or we can't create it manually.
		- If this tablespace is not available then we can't create it manually.
		- SYSTEM tablespace store core oracle data dictionary and internal objects.
		- Its status must be ONLINE.
		- It has only one datafile.
		
	2. Sysaux
		- Sysaux stand for system Auxillary Tablespace.
		- It is introduced in Oracle 10g
		- It is mandatory tablespace and it is created during DB creation.
		- We can't create this tablespace manually 
		- We can't drop this tablespace
		- It store metadata for oracle features and components.
		- This tablespace is helping to keep system tablespace small and stable.
		- Sysaux tablespace can contain one or more datafiles.
		
	3. Temp
		- Temp stand for Temporary Tablespace
		- This tablespace act as working area 
		- This tablespace stores immediate result during query processing 
		  like sorting,Group by,Joins,Index creation,Distinct.
		- During DB creation this tablespace get created but based on our requirement 
		  we can create our own TEMP tablespace. 
		- We can drop this tablespace.
		- Atleast one TEMP tablespace must be available in database.
		- A TEMP tablespace can have multiple temp datafiles(tempfiles)
		  
	4. Undo
		- This tablespace is created automatically during DB creation.
		- If we want to create our own UNDO tablespace,we can create.
		- UNDO tablespace store Old version of Data(Before changes)
		- We can drop this tablespace.
		
	5. User
		- This tablespace is created automatically during DB creation
		- If we want to create our own User tablespace we can create 
		- It store normal user table,index and other database objects.
		- We can drop this tablespace.
		
NOTE: 
	-> SYSTEM tablesapce is created with one datafile by default 
		but it can have multiple datafiles if required
	-> SYSAUX tablespace is created with one datafile by default 
		but it can contain multiple datafile depending on database growth 
	-> UNDO tablespace is created with one datafile by default 
		but it can contain multiple datafile if required.
	-> TEMP tablespace is created with one datafile by default 
		but it can contain multiple datafile if required.
	-> USER tablespace is created with one datfile by default
		but it can contain multiple datafile if required.
------------------------------------
Q.. What is DataFiles?
==> DataFiles store actual data.
	- DataFiles has extention .dbf
	- DataFiles information is stored in data dictionary view and view name is "DBA_DATA_FILES"
		SELECT * FROM DBA_DATA_FILES
	- DataFiles are created at the time of tablespace creation.
------------------------------------
Q.. Query to know information about DataFiles?
==> SELECT * FROM DBA_DATA_FILES;
------------------------------------
Q.. What is Data block?
==> Data block is smallest unit of Storage.
	- Data block store actual table row 
	- Data block size is defined at the time of DB creation and it is fixed 
	- commonly block size is 8kb 
	- oracle always read 8 kb at a time 
	Query to know block size 
	=> select * from v$parameter Where name='db_block_size';
------------------------------------
Q.. What is Extent?
==> - collection of data block is nothing but Extent.
	- Its size grows automatically as you insert data into tables.
	- To check extent informtion queries 
		1. select * from DBA_EXTENTS
		2. select * from USER_EXTENTS
------------------------------------
Q.. What is Segment?
==> - collection of extent is nothing but Segment.
	- segment is created when you create an object.
	- To check segment informtion we have queries 
		1. select * from DBA_SEGMENTS
		2. select * from USER_SEGMENTS
------------------------------------
Q.. General syntax to create Tablespace?
==> CREATE TABLESPACE tablespace_name
	DATAFILE 'path_of_data_file1','path_of_data_file2'
	SIZE size 
	[AUTOEXTENT ON|OFF] [NEXT size]
	[MAXSIZE size|unlimited]
	[EXTENT MANAGEMENT local]
	[SEGMENT SPACE MANAGEMENT AUTO|MANUAL]
	[LOGGING|NOLOGGIN]
	[ONLINE|OFFLINE]
	
	- If we don't specify AUTOEXTENT then default is OFF 
	- If we don't specify MAXSIZE then default is 
		1. if AUTOEXTENT is OFF => max size=current size 
		2. if AUTOEXTENT is ON => max size=unlimited
	- If we don't specify EXTENT MANAGEMENT then default is local 
	- If we don't specify SEGMENT SPACE MANAGEMENT the default is auto 
	- If we don't specify LOGGING then default is LOGGING 
	- If we don't specify STATUS then default is ONLINE
	- Order of parameter is not important here 
	
	e.g
	create tablespace my_tablespace
	DATAFILE 'C:\ORACLEXE\ORADATA\XE\my_tablespace.DBF' SIZE 50M
------------------------------------
Q.. Syntax to create custome TEMP tablespace?
==> CREATE TEMPORARY tablespace tablesapce_name 
	TEMPFILE 'path_of_data_file1','path_of_data_file2'
	SIZE size 
	[AUTOEXTENT ON|OFF][NEXT size]
	[MAXSIZE size|unlimited]
	[EXTENT MANAGEMENT local]
	[SEGMENT SPACE MANAGEMENT manual]
	
	Note: 
	1. for TEMP tablespace datafiles are not available
	2. for TEMP tablespace tempfiles are available
	3. TEMP files are available in 'DBA_TEMP_FILES'

	4. for temp tablespace below parameters are not allowed
		1. SEGMENT SPACE MANAGEMENT AUTO => not allowed 
		2. LOGGING|NOLOGGING
			temp tablespace are always NOLOGGING bydefault we can't specify NOLOGGING explicitly
		3. ONLINE|OFFLINE
			Temporary tablespace are always ONLINE by default we can't specify ONLINE/OFFLINE
------------------------------------
Q.. How to add data files to tablespace?
==> to add data files to tablesapce we need to alter table 
	Syntax: 
		Alter tablespace name_of_tablespace
		Add datafile 'path_of_data_file'
		SIZE size 
		[Autoextend on|off][NEXT size]
		[maxsize size|unlimited]
------------------------------------
Q.. Resize existing data files
==> - Resizing means increase or decrease the size of datafiles 
	- We can increases the size of datafile but we can't decrease size of datafiles below the used space.
	Alter database datafile 'path'
	Resize size;
------------------------------------
Q.. Syntax to enable or disable AUTOEXTEND?
==> Alter database datafile 'PATH'
	autoextend off [maxsize size]
	
	Alter database datafile 'PATH'
	autoextend on [next size] [maxsize size]
------------------------------------
Q.. How to make ONLINE/OFFLINE tablespace?
==> alter tablespace tablespace_name ONLINE|OFFLINE

	Note: we can't OFFLINE => system,sysaux and temp
------------------------------------
Q.. How to rename tablespace?
==> rename tablespace tablespace_name rename to new_tablespace_name;
------------------------------------
Q.. How to drop tablespace?
==> drop tablespace tablespace_name;
------------------------------------
Q.. Creating table with tablespace?
==> When we create table without specifying tablespace then table get created in default tablespace.
	for e.g 
		create table table_name(....) => created in default tablespace 
	- check your default tablespace 
		select * from user_user where username='user_name';
		select * from dba_users where username='user_name'
	- if we want to create table with tablespace then 
		syntax
		create table table_name(....)tablespace tablespace_name
------------------------------------
Q.. What is an user in Oracle?
==> A login account in Oracle Database?
------------------------------------
Q.. How to create user?
==> Syntax: 
	CREATE USER username IDENTIFIED BY password
	[DEFAULT TABLESPACE tablespace_name]
	[TEMPORARY TABLESPACE temp_tablespace_name]
	[QUOTA size|UNLIMITED ON tablespace_name]
	[PROFILE profile_name]
	[PASSWORD EXPIRED]
	[ACOOUNT LOCK|UNLOCK];
	
	- above syntax create user but user can't login immediately we 
	  GRANT CREATE SESSION Privilege explicitly to that user.
	- Syntax to privide CREATE SESSION Privilege
		GRANT privilege_name TO user_name 
	- Parameters specified in square bracket are optional
	  to create user we can use below syntax 
	  CREATE USER username IDENTIFIED BY password;
	- Example:
		CREATE USER orauser1 IDENTIFIED BY orauser1;
	-> Created user information is available in 
		DBA_USERS,ALL_USERS AND USER_USERS
	   we can view the information by executing select query as 
	   select * from DBA_USERS
	   select * from USER_USERS
	   select * from ALL_USERS
	-> Keywords explaination
		1. DEFAULT TABLESPACE: When user created object are stored.
			- this parameter is an optional 
			- if we don't specify this parameter,oracle engine uses databse
			  default tablespace (usually users)
			- To check database default tablespace 
				select * from DATABASE_PROPOERTIES where 
				PROPERTY_NAME='DEFAULT_PERMANENET_TABLESPACE';
		
		2. TEMPORARY TABLESPACE: Which tablespace used for temp operations
			- This parameter is an option 
			- If we don't specify this parameter.oracle engine uses database
			  default tablespace(Usually TEMP)
			- Query to check default temp tablespace 
				select * from DATABASE_PROPOERTIES where 
				PROPERTY_NAME='DEFAULT_TEMP_TABLESPACE'
		
		3. QUOTA: Space limit on tablespace.How much space user can consume
			- This parameter is an optional 
			- If we don't specify this parameter,user has zero space.
			- If QUOTA is zero,user can't create tables.
			- We can check Quota for user 
				select * from DBA_TS_QUOTAS where username='username'
			  if above query returns zero rows means no quota is allocated for given user 
			  
		4. PROFILE:Resource and password rules
			- This parameter is an optional 
			- If we don't specify this parameter,name of PROFILE is DEFAULT
			- PROFILE information is available in 'DBA_PROFILES'
			- To check profile information use below query	
				select * from DBA_PROFILES 
		
		5. PASSWORD: Value is EXPIRED 
			- this parameter is an optional 
			- If we don't specify this parameter,passoword is not expired.
			- If we specify EXPIRED,Oracle engine forcess to change the passoword on first login
			
		6. ACCOUNT: Account status
			- This parameter is an optional 
			- If don't specify this parameter,default is UNLOCK(open)
			
	- Alter user 
		1. Change the Password
		-> Syntax: 
			ALTER USER user_name IDENTIFIED BY new_password;
		
		2. Lock or Unlock the user
		-> Syntax: 
			ALTER USER user_name ACCOUNT LOCK|UNLOCK;
		
		3. Change the default tablespace
		-> Syntax: 
			ALTER USER user_name DEFAULT TABLESPACE new_tablespace_name;
			
		4. Change the QUOTA
		-> Syntax: 
			ALTER USER user_name QUOTA 20M ON tablespace_name;
------------------------------------
Q.. How to DROP user?
==> Syntax: 
	DROP USER user_name [CASCADE]
	
	- CASCADE is an optional parameter 
	- if no object is associated with user then no need to user CASCADE.
	- If any object is associated with user then we can't drop user in normal way 
		DROP USER user_name Syntax can't drop user.
	- In that case first drop all objects associated with that user and then drop user but 
	  we can use CASCADE keyword to drop user along with his/her objects 
	  DROP USER user_name CASCADE;
	
	But in real time droping the objects is not recommonded 
	for that we have an alternative ways 
	1. move all objects associated with that user to other user 
	2. Loct the user account 
	
------------------------------------
Q.. About PROFILE parameter of user creation syntax: 
==> PROFILE: Resource and password rules 
	-> Profile parameter is an optional.If we don't specify 
	   profile parameter name then Oracle engine assign DEFAULT 
	-> One user can have one profile or many users can have one profile 
	-> Default profile name is 'DEFAULT' automatically assigned if no profile is specified.
	-> Default profile cannot be dropped 
	-> Profile information is available in 'DBA_PROFILES' data dictionary view.
	-> To check profile information use below query 
		SELECT * FROM DBA_PROFILES WHERE profile='DEFAULT'
	-> we can create custome profile 
		CREATE PROFILE profile_name 
		LIMIT 
		resource_name1 {integer|UNLIMITED|DEFAULT}
		resource_name2 {integer|UNLIMITED|DEFAULT}
		resource_name3 {integer|UNLIMITED|DEFAULT}
		
	# Important PROFILE parameters 
	A. Password related PROFILE parameters 
		1. FAILE_LOGIN_ATTEMPTS
		-> maximum number of wrong password attempts allowed 
		-> For DEFAULT profile its value is 10 
		-> For custom profile its default value is 'DEFAULT'
			'DEFAULT' means 'inherit value from DEFAULT PROFILE'
		-> FAILED_LOGIN_ATTEMPTS 3 
		-> affter 3 wrong logins -> account gets LOCKED
		
		2. PASSWORD_LIFT_TIME
		-> How many days a password is valid.
		-> For DEFAULT profile its value is 'UNLIMITED'
		-> For Custom profile default value is 'DEFAULT'
		-> PASSWORD_LIFE_TIME 60 
			password expires after 60 days 
			
		3. PASSWORD_REUSE_TIME 
		-> Minimum days before reusing an old password 
		-> For DEFAULT PROFILE its value is UNLIMITED 
		-> for custom profile its default value is 'DEFUALT'
		-> Password_reuse_time 30 
			cannot reuse old password for 30 days
		
		4. PASSWORD_REUSE_MAX
		-> Number of passowrd changes required before reuse 
		-> for default profile its value is unlimited 
		-> for custom profile its default value is default 
		-> password_reuse_max 5 
		   must change password 5 times before reusing an old one 
		   
		5. PASSWORD_LOCK_TIME 
		- How long(in days) the account remains locked after failed logins.
		- For default profile its value is unlimited 
		- for custom profile default value is default 
		- passoword_lock_time 1 
		- Account unlocks automatically after 1 day
		
		6. PASSWORD_GRACE_TIME 
		- Extra days user can login after password expiry(warning period)
		- For default profile its value is unlimited 
		- for custom profile its default value is 'default'
		- password_grace_time 7
		User get 7 days warning before forced change 
		
		7. PASSWORD_VERIFY_FUNCTION
		- PL/SQL function that checks password strength 
		- For default profile its value is null 
		- null means no password complexity check 
		- for custom profile default value is 'default'
		
	B. Resource-related PROFILE parameters
		1. sessions_per_user 
		- Maximum concurrent logins allowed per user 
		- for default profile its value is unlimited
		- for custom profile its default value is 'default'
		- sessions_per_user 2 
		  only 2 sessions at a time 
		  
		2. cpu_per_session
		- Total cpu time (in hundreth of seconds) allowed per session
		- for default profile its value is unlimited
		- for custom profile default value is 'default'
		- cpu_per_session 10000
			session ends after CPU limit reached 
			
		3. CPU_PER_CALL
		- cpu time  limit per SQL call,not per session
		- for default profile its value is unlimited
		- for custom profile its default value is default 
		- CPU_PER_CALL 1000
			one heavy query can be stopped 
			
		4. CONNECT_TIME 
		- Maximum total connected time (minutes) per session 
		- for default profile its value is 'unlimited'
		- for custom profile its default value is 'default'
		- CONNECT_TIME 120 
			session disconnects after 2 hours 
			
		5. IDLE_TIME 
		- Max inactive time (minutes) before session is disconnected 
		- for default profile its value is 'unlimited'
		- for custom profile its default value is 'default'
		- IDLE_TIME 30 
			No activity for 30 mins -> session killed 
			
		6. LOGICAL_READS_PER_SESSION
		- Max number of buffer reads per session 
		- for default profile its value is 'unlimited'
		- for custom profile its default value is 'default'
		- LOGICAL_READS_PER_SESSION 100000
			prevents heavy read operations
			
			
------------------------------------
Q.. General syntax to create tablespace (same as upper)
==> CREATE TABLESPACE tablespace_name
	DATAFILE 'path_of_data_file1','path_of_data_file2'
	SIZE size 
	[AUTOEXTENT ON|OFF] [NEXT size]
	[MAXSIZE size|unlimited]
	[EXTENT MANAGEMENT local]
	[SEGMENT SPACE MANAGEMENT AUTO|MANUAL]
	[LOGGING|NOLOGGIN]
	[ONLINE|OFFLINE]
	
	e.g 
		CREATE TABLESPACE pl_sql_dev_ts
		DATAFILE 'C:\ORACLEXE\ORADATA\XE\pl_sql_dev_ts.DBF'
		SIZE 50M
		AUTOEXTEND ON NEXT 10M
		MAXSIZE 100M
		EXTENT MANAGEMENT Local
		SEGMENT SPACE MANAGEMENT MANUAL 
		LOGGING 
		ONLINE;

Q.. create custome profile ? 
	Syntax: 
		CREATE PROFILE profile_name 
		LIMIT 
		resource_name1 {integer|UNLIMITED|DEFAULT}
		resource_name2 {integer|UNLIMITED|DEFAULT}
		resource_name3 {integer|UNLIMITED|DEFAULT}
		
	e.g. 
		CREATE PROFILE pl_sql_dev_profile 
		LIMIT
		FAILED_LOGIN_ATTEMPTS 7 
		PASSWORD_LIFE_TIME 90
		PASSWORD_LOCK_TIME 1 
		SESSIONS_PER_USER 2
		
	- Profile password rule work bydefault but resource limit do not work by default.we need to enable 
	  resource limit explicitly.so profiles work fully only if we enable resource limit 
	- Syntax to enable resource limit 
		alter system set resource_limit='true';
	- Resource limit is system level not for profile level 
	  so we need enable ones and get applied to all profiles 
	  
	- To check current value of resource limit syntax is?
		select name,value from v$parameter where name='resource_limit';
		
Q.. How to create user?
syntax: CREATE USER username IDENTIFIED BY password
		[DEFAULT TABLESPACE tablespace_name]
		[TEMPORARY TABLESPACE temp_tablespace_name]
		[QUOTA size|UNLIMITED ON tablespace_name]
		[PROFILE profile_name]
		[PASSWORD EXPIRED]
		[ACOOUNT LOCK|UNLOCK];
		
	e.g 
		CREATE USER rrdtnp IDENTIFIED BY rrdtnp
		DEFAULT TABLESPACE pl_sql_dev_ts
		TEMPORARY TABLESPACE TEMP 
		QUOTA UNLIMITED ON pl_sql_dev_ts
		PROFILE pl_sql_dev_profile
		
	- Once user creation done then created user can't login
	  if we try to login,we will get an error
	  REASON: 
------------------------------------
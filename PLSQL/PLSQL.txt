============== PLSQL =================

Q.. What is Trigger?
==> Trigger is stored procedure in Oracle that automatically executed or fired
	when a specific event occur on a table,view or database.
----------------------------------------
Q.. What is mean by stored procedure?
==> - When we execute SQL query then internally 
      SQL query get Parsed=>Compiled=>Executed
	- IF we execute same query multiple time then every time 
	  query get Parsed,Compiled and executed.
	- Stored procedure means A precompiled and stored SQL program inside the database
	  can be executed repeatedly.
----------------------------------------
Q.. Usage or Purpose of Trigger?
==> It is used for 
	1. Data Validation.
	2. Enforcing business rules.
	3. Auding changes or deriving values.
----------------------------------------
Q.. Types of trigger?
==> Triggers are classified based on Event Type,Timing,Scope(level)
	
	A) Based on Event Type: 
		1. DML Trigger
			The trigger which fired on DML operation is called DML Trigger 
			DML operations are INSERT,UPDATE,DELETE.
		
		2. DDL Trigger: 
			The trigger which fired on DDL operation is called DDL Trigger 
			DDL operations are CREATE,ALTER,DROP
		
		3. Database event trigger or System event triggers
			The trigger which perform on database event is called database event trigger 
			for e.g => LOGON,LOGOFF,STARTUP,SHUTDOWN.
			
	B) Based on Timing
		1. Before Trigger: fires before the DML event 
		2. After Trigger: fires after the DML event 
		
	C) Based on Scope(level)
		1. Statement level trigger- Fire once per statement 
		2. Row level trigger - fire once per row affected 
		
	D) Other Special types Not seperate categories 
		1. Instead of trigger 
			It is special type of trigger 
			It is applicable only for views 
			Used when view are not directly updatable 
			
		2. Compound Trigger 
			It is special case of row/statement trigger 
			combines all four timing points 
			BEFORE ROW 
			AFTER ROW 
			BEFORE STATEMENT
			AFTER STATEMENT
----------------------------------------
Q.. Syntax of DML Trigger?
==> CREATE [OR REPLACE] TRIGGER Trigger_name 
	{BEFORE | AFTER | INSTEAD OF}
	{INSERT | UPDATE [OF clm1,clm3...N] | DELETE }
	ON table_name_or_view_name 
	[FOR EACH ROW]
	[WHEN (condition)]
	DECLARE 
		-- optional : variable declartion
	BEGIN
		-- trigger logic 
	EXCEPTION
		-- optional: error handling 
	END;
	/
	
	
	here 
		The portion mentioned in [] is optional part 
		so in above syntax: 
			OR REPLACE
			OF clm1,clm2
			FOR EACH ROW 
			WHEN(condition)
		are the optional parameter.
		
		1. FOR EACH ROW : 
			- it is optional part 
			- FOR EACH ROW means it is row-level trigger 
			- FOR EACH ROW means trigger will execute once for each row affected by the DML statement 
			- If we don't use FOR EACH ROW then trigger become statement level trigger 
			- statement level trigger fire once no matter how many rows affected
			
		2. DECLARE
			- it is used to declare the variable,constant and cursor declartion.
			
		3. BEGIN ... END
			- BEGIN section is mandatory and it is called as trigger body 
			- it is executable part 
			- it contains executable logic for the trigger 
			- every BEGIN block must be end with "END"
			- We can write multiple BEGIN and END block for one trigger 
			
		4. EXCEPTION
			- EXCEPTION is used to write error handling code 
			- It is optional block but recommended 
			
		/ => it is end of CREATE TRIGGER BLOCK
------------------------------------	
Q.. Which statement are allowed in trigger body?
==> allowed statements are INSERT,UPDATE,DELETE,SELECT
------------------------------------	
Q.. Which statements are not allowed in trigger body?
==> CREATE,DROP,ALTER,COMMIT,ROLLBACK
------------------------------------
Q.. Consider Employee table when a row is inserted into Employee table 
	then insert a record into audit_log table.
==> CREATE trigger employee_tgr 
	After INSERT on employee 
	FOR EACH ROW 
	Begin
		INSERT INTO audit_log(LOG_ID,MSG,INSERT_DATE,USER_NAME) values(audit_log_sequence.nextval,'data added',sysdate,'yash');
	END 
	/
------------------------------------
Q.. Can we write TCL(COMMIT,ROLLBACK,SAVEPOINT) statement in trigger body?
==> If we write TCL statements in trigger,trigger is created,we don't get any error 
	but at the time of execution it give an error
	so,final conslusion is TCL statements are not allowed in the trigger body.
------------------------------------
Q.. If trigger body insert data into table,how will that data get committed if
	COMMIT is not allowed in Trigger?
==> The COMMIT operation is done by session that fired the trigger not by trigger itself
------------------------------------
Q.. If trigger body is performing DML operation,how will that data get committed 
	if COMMIT is not allowed in Tigger?
==> The COMMIT operation is done by the session that fired the trigger not by trigger itself	
------------------------------------
Q.. Write trigger which does not allow salary decrease?
==>CREATE OR REPLACE TRIGGER salary_tgr
	BEFORE UPDATE on emp11
	FOR EACH ROW 
	BEGIN
		IF :OLD.salary>:NEW.salary THEN
		RAISE_APPLICATION_ERROR(-20001,'You cannot decrease salary');
		END IF;
	END;
	/
	
	
	here 
		if we are using OLD and NEW keyword inside BEGIN block then we need to use : 
		otherwise we will get an error 
		
		
	CREATE TRIGGER salary_tgr
	BEFORE UPDATE on emp11
	WHEN(NEW.salary<OLD.salary)
	BEGIN	
		RAISE_APPLICATION_ERROR(-20001,'You cannot decrease salary');
	END;
	/		
------------------------------------
Q.. What is RAISE_APPLICATION_ERROR in oracle?
==> - RAISE_APPLICATION_ERROR is build in procedure
	- it is used to generate custom error message in PLSQL
	- we can use this procedure in trigger,procedure or function
	- This is useful when you want to enforce business rule or 
	  inform users of specific problem 
	- Syntax:
		RAISE_APPLICATION_ERROR(error_number,message [,{true | false}]);
	- It accept 3 input arguments first input argument is error number,
	  second input argument is error message,third argument is True or False value.
	
	1. error_number: A negative integer between -20000 to -20999 used as the error code.
	
	2. message: A string message explaining the error (max 2048 character)
	
	3. TRUE | FALSE: It is optional.TRUE propogate the error to the client
	   FALSE log it but does not propogate it.
------------------------------------
Q.. What is PL/SQL block?
==> It is structured way of writing Pl/SQL code 
	It consist of three sections: declartion section,
	executable section and the exception handling section
	
	- Syntax: 
		DECLARE
			-- declare the variable // this is optional 
		BEGIN
			-- executable section 
			-- it is mandatory section 
		EXCEPTION
			--Error/EXCEPTION handling section
			-- it is optional 
		END;
------------------------------------
Q.. Types of PL/SQL block?
==> PL/SQL block can be IMPLICIT or EXPLICIT 
	Implicit means created by oracle 
	Explicit means create by developer 
	Explicit block can be anonymous block or named block 
	
	1. Implicit: 
		- Automatically created by oracle engine
		- we cannot see these blocks 
		- example: 
			1. Each SQL statement run in an implicit PL/SQL block 
			2. Exception like no_data_found are raised automatically
			
	2. Explicit: 
		- Block written by developer is called explicit block 
		- Developer can control the structure 
		- Explicit block are 2 types 
			1. Anonymous block 
			2. Named block 
			
			1. Anonymous block: 
				- block without name is called Anonymous block
				=> Properties 
					- it is nameless 
					- Anonymous block is not stored in the database 
					- It is used for quick testing 
					- Execute immediately 
					- cannot be called again 
				=> Structure 
					DECLARE
						-variable declaration 
					BEGIN
						--executable statement 
					EXCEPTION
						--optional 
						--exception handlers 
					END;
			
			2. Named block : 
				- The block which has name is called Named block 
				=> properties 
					- named block is stored in the database 
					- it can be reused 
				=> Types of named block 
					1. Procedures 
					2. Function
					3. Trigger
					4. Packages
------------------------------------
Q.. What is the purpose of / in PL/SQL?
==> / is used to execute block in SQL plus or SQL developer
------------------------------------
Q.. Nesting of PL/SQL block?
==> Nesting of block in PL/SQL means placing one block inside another block
	
	=> Example: 
		DECLARE 
		-- variable declaration for outer block 
		BEGIN
		-- outer block BEGIN
			DECLARE 
			-- inner block declare section 
			BEGIN
			-- inner block begin section
			END;--end of inner block 
		END;--end of outer block 
		
	- Block statements are executed from top to bottom.
	- Inner block can have its own DECLARE section 
	- Variables in inner block are local to that block 
	- Outer block variable can be used in inner block but 
	  inner block variable can't be used in outer block 
	- Same variable we can declare in inner block 
	
------------------------------------
Q.. Write PL/SQL Block to print 'Good Morning' message on console?
==> 
	BEGIN
		DBMS_OUTPUT.PUT_LINE('Good Morning');
	END;
	/
------------------------------------
Q.. Write PL/SQL block to display user name along with Greet message ('Good Morning)?
==>	
	DECLARE
	v_user_name;
	BEGIN
	select user into v_user_name from dual;
	DBMS_OUTPUT.PUT_LINE('Good Morning' || v_user_name);
	END;
	/
------------------------------------
Q.. Write PL/SQL block to display today's date 
==> 
	DECLARE
	v_date date;
	BEGIN
	select sysdate into v_date from dual;
	DBMS_OUTPUT.PUT_LINE('today date is ' || v_date);
	END;
	/
------------------------------------
Q.. Write PL/SQL block to display date in format 'DD-MON-YYYY'?
==> 
	DECLARE
	v_date varchar(90);
	BEGIN
	select to_char(sysdate,'DD-MON-YYYY') into v_date from dual;
	DBMS_OUTPUT.PUT_LINE(v_date);
	END;
	/
------------------------------------
Q.. Write PL/SQL block to display name of Employee whose emp_id is 101?
==>  
	DECLARE
	v_name varchar(90);
	BEGIN
	select emp_name into v_name from emp11 where emp_id=101;
	DBMS_OUTPUT.PUT_LINE(v_name);
	END;
	/
------------------------------------
Q.. Write PL/SQL program to display emp_name and dept_id of Employee whose emp_id is 101?
==> 
	DECLARE
	v_name varchar(90);
	v_dept_id varchar(90);
	BEGIN
	select emp_name,dept_id into v_name,v_dept_id from emp11 where emp_id=101;
	DBMS_OUTPUT.PUT_LINE(v_name ||' '|| v_dept_id);
	END;
	/
------------------------------------
Q.. Write PL/SQL program to display all details of Employee whose emp_id is 101;
==> 
	DECLARE
	v_emp_id number;
	v_emp_name varchar(90);
	v_dept_id number;
	v_salary number;
	v_manager_id number;
	v_hire_date date;
	v_gender varchar(90);
	BEGIN
	select EMP_ID,EMP_NAME,DEPT_ID,SALARY,MANAGER_ID,HIRE_DATE,GENDER 
	into v_emp_id,v_emp_name,v_dept_id,v_salary,v_manager_id,v_hire_date,v_gender 
	from emp11 where emp_id=101;
	DBMS_OUTPUT.PUT_LINE('employee details as below');
	DBMS_OUTPUT.PUT_LINE(v_emp_id || ' ' ||v_emp_name 
	|| ' ' || v_dept_id || ' ' ||v_salary|| ' ' ||v_manager_id
	|| ' ' ||v_hire_date|| ' ' ||v_gender );
	END;
	/
------------------------------------
Q.. What is mean by variable?
==> Variables are placeholder which hold value temporary the execution of PL/SQL block.
------------------------------------
Q.. Where do we declare variable?
==> A variable must be declare inside the DECLARE section of PL/SQL block.
	Syntax: 
		variable_name data_type [not null] [:=initial_value]
	
	not null => means variable not hold null value at any time 
	
	RULE FOR NAMING PL/SQL VARIABLE: 
	1. If you declare variable with NOT NULL,you must initilize variable at the time 
	   of declaration,otherwise we will get an error 
	2. If you delcare variable with NOT NULL and later you assign value to variable then 
	   oracle engine raise an exception.
	3. Variable name can be combination of uppercase character,lowercase character,digit
	   and special symbols underscore(_),doller($),hashtag(#).
	4. Variable name must be start with letter.
	5. Variable name should not be start with number or special symbol.
	6. Keywords are not allowed for variable name.
	7. Blank space is not allowed in variable name.
	8. maximum length of variable is 30 character
	9. Variable names are not case sensitive
------------------------------------
Q.. Initilization of Variable?
==> Initilization means assigning value to variable
	- we can Initilize variable using 2 ways
		1. using assignment operator (:=)
		2. using DEFAULT keyword
	- we can Initilize variable at the time of declaration or after the declaration. 
	- If we declare variable then we can Initilize only in BEGIN section 
	  otherwise we will get an error 
	- If we want to initilize variable after the declartion inside the BEGIN section 
	  then we need to use (:=) operator,if we use DEFAULT then we will get an error.
------------------------------------
Q.. Classification of Variable?
==> 1. Data type based variable
	2. Scope based variable
------------------------------------
Q.. Classification based on Data type?
==> Data type based variable means which type of value hold by variable 
	we have below types 
	1. Scalar variables
	2. Composite variables
	3. Reference Variable
	4. LOB Variable
------------------------------------
Q.. What is mean by scalar variable?
==> The variable which hold single value at a time is know as scalar variable 
	- scalar variables are also called as atomic variables or single valued variables 
------------------------------------
Q.. What is mean by Composite variable?
==> The variable which hold multiple value at a time is called as Composite variable.
------------------------------------
Q.. What is Reference variable?
==> The variable which hold reference of another variable is called Reference variable.
------------------------------------
Q.. What is mean by LOB variable?
==> The variable which hold large object are called LOB variable.
------------------------------------
Q.. Classification based on scope of variable?
==> Scope of variable means where the variable can be accessible.
	1. Local variable
	2. Global variable 
	3. Formal parameters
	4. Bind variable
------------------------------------
Q.. What is Local variable?
==> The variable declared inside block is nothing but local variable 
	- Local variable can be used within that block 
	- Outside the block they are not accessible
	- If we have nexted block then outer block variable can be accessible inside inner block
	  but inner block variable not accessible inside outer block 
------------------------------------
Q.. What is Global variable?
==> The variable declared inside package specification is called global variable.
	- Global variable are accessible to all procedures/functions inside the package
------------------------------------
Q.. What is Formal Parameter?
==> Variable declared inside procedure/functions as a parameter are called as Formal Parameter
	- Formal parameter are accessible any where within that procedure/functions.
------------------------------------
Q.. What is Bind Variable?
==> A variable whose value is supplied at execution time and bound to 
    SQL statement is called bind variable
	==> How to declare bind variable 
		- Bind variable not declared inside PL/SQL DECLARE section 
		- They are declared at the client tool level,using syntax 
		  VARIABLE var_name data_type;
		  Example: 
		  VARIABLE v_empname VARCHAR(100);
		  
		- How to assign value to variable 
			1. Syntax for EXEC 
			EXEC :variable_name :=value;
			Example
			EXEC :variable_name :=value;
		    
			2. Syntax for Begin...End
			BEGIN
			:variable_name:=value;
			END;
			/
------------------------------------
Q.. What is Scope of Bind variable?
==> Bind variables have SESSION scope - they exist and remain 
	accessible as long as your database session is active.
------------------------------------
Q.. Why it is called Bind?
==> Because of value is bound (attached) to the SQL statement during execution
	- Databse parses the SQL only once and later you can send new values without parsing again 
------------------------------------
Q.. can we declare bind variable inside DECLARE section?
==> No - we cannot declare bind variable inside DECLARE section.
------------------------------------
Q.. PL/SQL Anchored data types : %TYPE and %ROWTYPE
==> Anchored data types link a varaibles data type to a database column or table row 
	so if the table changes,your PL/SQL code does not break.
------------------------------------
Q.. What is %TYPE 
==>	- If we want to store column types value then use %TYPE 
	- %TYPE allows PL/SQL variable to inherit the data type and size of a table column 
	- Benefit: If column data type changed then no need change PL/SQL code.
	- How to declare variable of %TYPE 
		Syntax: 
		variable_name table_name.column_name%TYPE 
		
		e.g 
			DECLARE 
			v_empname emp11.emp_name%TYPE;
			BEGIN
			 select emp_name into v_empname from emp11 where emp_id=101;
			 dbms_output.put_line(v_empname);
			END;
			/
			
	- If we want to store column value then use %TYPE 
------------------------------------
Q.. How many value %TYPE variable holds?
==> only one at a time 
------------------------------------
Q.. Does %TYPE store multiple rows or values?
==> No
------------------------------------
Q.. What does %TYPE do?
==> It copies datatype,size,precision,scale.
------------------------------------
Q.. What is %ROWTYPE?
==> %ROWTYPE allows variable to hold entire row of table or cursor.
	- %ROWTYPE always store all column 
	- We can't use %ROWTYPE to store perticular column
	How to declare %ROWTYPE
	 variable_name table_name%ROWTYPE
	 
	Exmple:
		DECLARE
		v_emprow emp11%ROWTYPE;
		BEGIN
		 select * into v_emprow from emp11 where emp_id=101;
		 dbms_output.put_line(v_emprow.emp_id || v_emprow.emp_name || v_emprow.salary);
		END;
		/
------------------------------------
Q.. What is Substitution variable?
==> Substitution variable is variable start with & or && and allows user to pass input at run time
	- Substitution varaible is used to get input from user at runtime 
	- They are not PL/SQL variables,but used in Oracle client tools like SQL Plus,SQL Developer.
	Syntax: 
		&variable_name 
		&&variable_name
------------------------------------
Q.. What is difference between '&variable_name' and '&&variable_name'?
==> &variable_name : Prompt every time(ask every time)
	&&variable_name: Prompt one time and store that value and reuse.
------------------------------------
Q.. What is CONSTANT Variable?
==> Variable whose value cannot be changed once it is assigned is nothing but CONSTANT variable.
	- it is useful for fixed values such as tax rates,PI,maximum limit or any value that 
	  should not change during execution.
	- Syntax: 
		Variable_name CONSTANT datatype :=value;
------------------------------------
Q.. NOT NULL is constraint in PLSQL?
==> In PL/SQL variables,NOT NULL is not a constraint,but a variable attribute.
	- It behave like a constraint,but it is not a database constraint.
------------------------------------
Q.. If we don't initilize variable then what is its default value?
==> default value of variable is null.
------------------------------------
Q.. What happen if we declare variable twice in same block?
==> - if we declare variable twice and not Initilize it then we don't get any error 
	- if we declare variable twice and Initilize it then we will get an error.
------------------------------------
Q.. Can we access outer block variable inside inner block?
==> Yes we can access 
------------------------------------
Q.. Can we access Inner block variable inside outer block?
==> No 
------------------------------------
Q.. When is a variable created in PL/SQL?
==> Variable created At the time of block execution.
------------------------------------
Q.. When is a variable destroyed in PL/SQL?
==> Ones block execution is completed then a variable destroyed from the memory.
------------------------------------
Q.. What is data type in PL/SQL?
==> which type of value store in variable is nothing but data type.
------------------------------------
Q.. Type of data type in PL/SQL?
==> 1. Scalar data type 
	2. Composite data type 
	3. Reference data type 
	4. LOB data type 
------------------------------------
Q.. Scalar data type?
==> - The data type which store single value at a time is called scalar data type.
	- Scalar data type is divided into different types 
		1. Numeric 
			- Number
			- PLS_Integer 
			- binary_float 
			- binary_double 
			
		2. Character
			- CHAR 
			- NCHAR 
			- VARCHAR2 
			- NVARCHAR2
			
		3. Date & Time 
			- DATE 
			- TIMESTAMP
			
		4. Boolean
			- BOOLEAN 
------------------------------------
Q.. NUMERIC 
==> 1. NUMBER:
	- It is used to store exact numeric value,including integer and fractional numbers.
	- Syntax:
		NUMBER(p,s)
		p:P stand for Precision.Precision means Total number of digit.
		s:S stand for Scale.Scale means Digits after decimal point 
	- Range of Precision is 1 to 38 and Range of scale is -84 to +127
	
	2. PLS_Integer
	- It is PL/SQL specific scale numeric data type.
	- It store only integer values.
	- If we assign decimal value then we will not getting any error.it will ignore 
	  decimal part and consider only integer.
	- It is fastest integer data type than number,binary_double,binary_float 
	  because it perform arithmatic operation at CPU-level
	- Its size 4 byte (32bit)
	- Range -2,147,483,648 to +2,147,483,647
	- If value exceed then we will get an error "numeric overflow"
	
	=> Where to use PLS_Integer
		1. Loop counters 
		2. Array Indexes 
		3. High performance numeric calculations 
		
	3. Binary_Float
	- It is 32 bit(4 byte),single precision floating point numeric data type.
	- 32 bit means it store 32 bit floating point number. 
	- It store approximately 6-7 decimal digit
	- It is faster than Number.
	- It is designed for high performance and scientific calculations, not exact precision.
	- It follows IEEE 754 single-precision floating point format.
	- Range 
		minimum positive value=> 1.175*10^-38
		maximum positive value=> 3.402*10^38
		
		
	4. Binary_Double
	- It is 64 bit (8-byte),double precision floating point numeric data type.
	- 64 bit (8byte) means it store 64 bit floating point number.
	- It is used when you need high speed numeric calculations with higher precision
	  than Binary_Float.
	- It stores approximately 15 to 17 decimal digit 
	- It provide more accurancy than Binary_Float
	- It follows IEEE-754 double-precision floating point format 
	- Range 
		Binary_Double store extremely large value (up to 10^308) and extremely small (down to 10^-324)
		with ~15-17 digit accurancy 
		
------------------------------------
Q.. IEEE-754 standard?
==> - Arithmatic calculations of floating point may vary from system to system 
	- so to overcome this problem IEEE created an international standard for floating-point 
	  arithmatic calculations and that standard is know as IEEE-754 standard 
	- Every floating-point arithmatic calculation has to follow IEEE-754 standard 
	  so as to get platform independent or machine independent result.
	- IEEE stands for Institute of Electrical and Electronics Engineers.
------------------------------------
Q.. Character Scalar Data Type?
==> 1. CHAR
	- Char stand for character 
	- it is fixed in length 
	- maximum size of char is 32,767 bytes 
	- default size is 1. 
	
	2. NCHAR
	- NCHAR stand for National Character
	- It is fixed length Unicode character data type in oracle.
	- It is used to store national character set data,which supports multiple languages
	  (like Hindi,Chinese,Arabic,etc)
	- PL/SQL min size for NCHAR is 1
	- SQL min size for NCHAR is 1 
	- PL/SQL max size for NCHAR is 32767 bytes 
	- SQL min size for NCHAR is 2000 bytes 
	- Default size of NCHAR is 1. 
	
	3. VARCHAR2
	- It is variable length character data type.
	- Variable means memory adjusted depending on actual string length.
	- PL/SQL max size of VARCHAR2 is 32767
	- SQL max size of VARCHAR2 is 4000.
	
	4. NVARCHAR2
	- NVARCHAR2 is variable length unicode character data type in oracle.
	- It store multi language string in the national character set.
	- PL/SQL max size is 32676 character.
	- SQL max size of NVARCHAR2 is 4000.
------------------------------------
Q.. What is difference between CHAR and NCHAR?
==> - CHAR stand for character where as NCHAR stand for National character
	- CHAR uses the database character where as NCHAR uses National character set 
	- CHAR uses minimum 1 byte per character where as NCHAR uses 2 byte per character.
	- CHAR may support Unicode depending on the database character set where as 
	  NCHAR always store Unicode data 
	- CHAR is typically used for English or single-byte character where as 
	  NCHAR is used for multilingual data
	- CHAR generally uses less storage where as NCHAR uses more storage.
	- CHAR is faster than NCHAR because it involves simpler encoding.
------------------------------------
Q.. Why there is size difference in SQL and PL/SQL?
==> SQL has smaller limits because data stored in tables.
	PL/SQL allows larger sizes because data is stored in memory only 
------------------------------------
Q.. What is mean by database character set?
==> Normal english set
------------------------------------
Q.. What is mean by National character set?
==> Multilingual/unicode text
------------------------------------
Q.. What is difference between VARCHAR2 and NVARCHAR2?
==> - VARCHAR2 stand for Variable length character data where as 
	  NVARCHAR2 stand for National Variable length character data 
	- VARCHAR2 uses database character set where as 
	  NVARCHAR2 uses National character set 
	- VARCHAR2 may support unicode character depending upon database character set where as 
	  NVARCHAR2 always support unicode character
	- VARCHAR2 uses less memory than NVARCHAR2
	- VARCHAR2 uses less disk space than NVARCHAR2
	- VARCHAR2 has better performance than NVARCHAR2
------------------------------------
Q.. In which use case would you choose each data type?
==> Number => use for exact number
	PLS_Integer => for fast integer operation
	Binary_Float => floating point calculation with less accurancy
	Binary_Double => floating point calculation with more accurancy
	CHAR => for fixed length database character set 
	NCHAR => For fixed length unicode character set 
	VARCHAR2 => for variable length database character set 
	NVARCHAR2 => for variable length unicode character set 
------------------------------------
Q.. Performance wise Order (Fast to slow) & Why?
		1. PLS_Integer
		2. Binary_Float
		3. Binary_Double
		4. Number
==> 1. PLS_Integer : directly processed by CPU and no conversion is required so it is fast 
	2. Binary_Float: 32 bit floating point number,small size,Less CPU work required
	3. Binary_Double: 64 bit floating point number,large size,more CPU work required
	
------------------------------------
Q.. COMPOSITE data type?
==> Composite data types are used to store multiple values in a single variable 
	1. RECORD 
	2. TABLE 
	3. NESTED TABLE 
	4. VARRAY
------------------------------------
Q.. REFERENCE data type?
==> REFERENCE data types are used to store memory addresss or pointers 
	1. REF CURSOR 
	2. CURSOR
------------------------------------
Q.. LOB(Large Object) Data types?
==> LOB Data types are used to imges,files,etc.
	1. BLOB(Binary Large Object)
	2. CLOB(Character Large Object)
	3. NCLOB(National Character Large Object)
	4. BFILE(Binary File stored outside database(OS File))
------------------------------------
Q.. What is Conditional statement in PL/SQL?
==> We have 2 type of conditional statements
	1. If statement
	2. Case expression
	- Case expression is used in SQL and PL/SQL but If statement is used only in PL/SQL
	- We can't use IF statement in SQL.
------------------------------------
Q.. IF statement?
==> - IF statement has 3 form 
	1. IF...THEN 
		IF condition THEN 
		statement1;
		statement2;
		.
		.
		statementN;
		END IF;
		
	2. IF...THEN...ELSE
		IF condition THEN
		statement1;
		statement2;
		.
		.
		statementN;
		ELSE
		statement1;
		statement2;
		.
		.
		statementN;
		END IF;
		
	3. IF...THEN...ELSIF...ELSE
		IF condition THEN 
		.
		.
		ELSIF
		.
		.
		ELSE
		.
		.
		END IF;
------------------------------------
Q.. What is SQL%ROWCOUNT ?
==> SQL%ROWCOUNT is an implicit cursor attribute that tell you: 
	how may rows were affected by the most recent SQL statement 
	(INSERT,UPDATE,DELETE,SELECT INTO)
------------------------------------
Q.. Date data type?
==> DATE is scalar data type in PL/SQL
	- DATE data type store data and time 
	- default date format is DD-MON-YY HH24:MI:SS
	- Even if you don't see time it is always stored.
	- DATE data type uses 7 bytes to store date value.
------------------------------------
Q.. TIMESTAMP data type?
==> TIMESTAMP is scalar data type 
	- it is used to store date and time
	- it is more Precise than DATE 
	- TIMESTAMP uses 11 byte to store value
	- 1 second =1000 miliseconds
	- 1 miliseconds = 1000 microseconds
	- 1 second = 10000 microseconds
	- e.g 
		DELARE
			v_time TIMESTAMP;
		BEGIN
			v_time systimestamp;
			dbms_output.put_line(v_time);
		END;
		/
------------------------------------
Q.. TIMESTAMP WITH TIME ZONE?
==> it is scalar data type 
	- it is used to store date and time with time zone 
	- e.g 
		DELARE
			v_time TIMESTAMP WITH TIME ZONE;
		BEGIN
			v_time systimestamp;
			dbms_output.put_line(v_time);
		END;
		/
------------------------------------
Q.. TIMESTAMP WITH LOCAL TIME ZONE?
==> it is scalar data type 
	- stored in database time,shown in your local time
	- save once globally,display according to user location
	- same data with different display 
	- This data type is best for global application
------------------------------------
Q.. INTERVAL YEAR TO MONTH
==> - it store difference in year and months 
	- difference in year and months 
	- suppose employee experience is 2 year and 3 months 
	  same is represented in INTERVAL YEAR TO MONTH 
	  INTERVAL '2-3' YEAR TO MONTH 
	e.g 
		DECLARE 
		 v_date INTERVAL YEAR TO MONTH;
		BEGIN
		 v_date :=INTERVAL '2-3' YEAR TO MONTH;
		 DBMS_OUTPUT.PUT_LINE(v_date);
		END;
		/
		
	O/P => +02-03
------------------------------------
Q.. INTERVAL DAY TO SECOND
==> it store difference in days,hours,minuts,seconds
	- Task ran for:
		2 days 5 hours 30 minuts 20 seconds.
	- above example can represent in INTERVAL DAY TO SECOND 
		INTERVAL '2 05:30:20' DAY TO SECOND
------------------------------------
Q.. Add one day in today's date?
==> select sysdate+1 from dual
------------------------------------
Q.. Add 2 hours in today's date?
==> select sysdate+2/24 from dual;// add 2 hour in today's date
------------------------------------
Q.. Add 30 min in today's date?
==> select sysdate+30/1440 from dual;
------------------------------------
Q.. Add 30 second in today's date?
==> select sysdate+30/86400 from dual;
------------------------------------
Q.. Add 2 days in today's date using INTERVAL?
==> select systimestamp+INTERVAL '2' DAY from dual;
------------------------------------
Q.. Add 2 hours in today's date using INTERVAL?
==> select systimestamp+INTERVAL '2' HOURS from dual;
------------------------------------
Q.. Add 3hours30minute in today's date?
==> select systimestamp + INTERVAL '3.30' HOURS TO MINUTE from dual;
------------------------------------
Q.. Add 2year6month in today's date?
==> select systimestamp + INTERVAL '2-6' YEAR TO MONTH from dual;
------------------------------------
Q.. write PL/SQL block to Display age of employee?
==> DECLARE
	 v_date number;
	BEGIN
	 select trunc(months_between(sysdate,hire_date)/12) into v_date  from emp11 where emp_id=101;
	 dbms_output.put_line(v_date);
	END;
	/
	
	DECLARE
	 v_date date;
	 v_age number;
	BEGIN
	 select hire_date into v_date  from emp11 where emp_id=101;
	 v_age:=trunc((sysdate-v_date)/365);

	 dbms_output.put_line(v_age);
	END;
	/
------------------------------------
Q.. Write PL/SQL block to check voteing ability?
==> DECLARE
	 v_date date;
	 v_age number;
	BEGIN
	 
	 select to_date('11-jul-2000') into v_date from emp11 where emp_id=101;

	 v_age:=trunc(months_between(sysdate,v_date)/12);

	 if v_age>18 then 
	  dbms_output.put_line('user able to do the voting');
	 else
	  dbms_output.put_line('user not able to do the voting');
	 end if;

	END;
	/
------------------------------------
Q.. Find experience in year and month?
==> DECLARE
	 v_exp date;
	 t_ex INTERVAL YEAR TO MONTH;
	BEGIN
	  
	 select hire_date into v_exp from emp11 where emp_id=101;

	 t_ex:=NUMTOYMINTERVAL(floor(months_between(sysdate,v_exp)),'MONTH');

	 dbms_output.put_line(t_ex);

	END;
	/
------------------------------------
Q.. NUMTOYMINTERVAL function?
==> NUMTOYMINTERVAL function is used to convert number into INTERVAL 
	Syntax:
		NUMTOYMINTERVAL(number,'YEAR'/'MONTH');
------------------------------------
Q.. CAST function?
==> CAST function is used to convert one data type into another data type
	syntax:
		CAST(source_value as target_date_type);
	e.g 
		select CAST(sysdate as TIMESTAMP) from dual;
------------------------------------
Q.. TO_TIMESTAMP function?
==> TO_TIMESTAMP function is used to convert date formated string into TIMESTAMP
	SYNTAX:
		TO_TIMESTAMP(string);
	e.g
		select TO_TIMESTAMP(sysdate) from dual
------------------------------------
Q.. Case expression?
==> Case expression is an alternative for multiple IF-ELSE statements
	Case expression has 2 type
	1. Simple Case expression 
	2. Searched Case expression
------------------------------------
Q.. What is Simple Case expression?
==> Simple Case Expression compares one expression with multiple values.
	- If we want to compare one expression with multiple values then we go with Simple Case expression.
	Syntax: 
		CASE expression 
		When value1 THEN statement1;
		When value2 THEN statement2;
		ELSE statements;
		END CASE;
------------------------------------
Q.. What is Searched Case?
==> If we have multiple multiple condition then go with Searched Case
	Syntax: 
		CASE 
		When condition1 THEN statement1;
		When condition2 THEN statement2;
		ELSE statement;
		END CASE;
------------------------------------
Q.. Write PL/SQL code to print Day name from Day number?
------------------------------------
Q.. Write PL/SQL code to print salary grade based on salary value?
------------------------------------
Q.. Write PL/SQL block to check voting Eligibility?
------------------------------------
Q.. Write PL/SQL block to check number is Even or ODD?
------------------------------------
Q.. Write PL/SQL block to grade student based on Mark?
------------------------------------
Q.. Difference between Simple case and Searched case?
==> - Simple case compares value where as Searched case evalutes condtion
	- Simple case have single expression where as Searched case have multiple conditions 
	- Simple case does not support operators where as Searched case support operators
------------------------------------
Q.. What is mean by short circuit?
==> Stopping the evalution of a condition as soon as final result is known.
	- In PL/SQL logical operators (AND,OR) uses short circuit evalution
------------------------------------
Q.. Why short circuit important?
==> - Improve Performance
	- Prevent runtime errors 
	- Used in real-time validation logic 
------------------------------------
Q.. What is mean by EXCEPTION?
==> unwanted or unexcepted event that break normal execution flow nothing but exception.
	if execption occure then rest of code is not execute.
------------------------------------
Q.. What is mean by Exception handling?
==> Exception handling means providing alternative way so that rest of code get executed if exception occured.
------------------------------------
Q.. Why exception handling required?
==> WITHOUT EXCEPTION HANDLING
	1. Program get terminated abnormally 
	2. No Chance to recover 
	-> WITH EXCEPTION HANDLING
		1. Error can be caught and managed 
		2. We can provide custom message if there is an exception
		3. Program terminated gracefully 
	-> Exception handling is not mandatory but it is recommended 
------------------------------------
Q.. How to handle exception in PL/SQL?
==> To handle exception we use EXCEPTION block 
	There is not seperate existence for EXCEPTION block 
	We need to write exception block inside the BEGIN block 
	- Syntax: 
		BEGIN
			statements;
		EXCEPTION
			statements;
		END;
		/
------------------------------------
Q.. Types of Exception?
==> there are 3 types of exceptions
	1. Predefined exceptions
	2. Non-Predefined exceptions
	3. User defined exceptions
------------------------------------
Q.. Predefined Exceptions:
==> The exceptions which are automatically raised by oracle engine with fixed name and 
	error code are called Predefined Exceptions.
	- Properties
	- Predefined exceptions are already declared so we don't need to declare under DECLARE section
	- Predefined exception have fixed name and error code 
	- Oracle engine raise it automatically
	
	- Predefined exceptions 
	1. NO_DATA_FOUND
	
	2. TOO_MANY_ROWS
	
	3. VALUE_ERROR 
		- it is predefined exception
		- error code: ORA-06502
		- When it is raised 
			1. When converting a value from one data type to another data 
			   and conversion is not allowed 
			2. When assigning a string longer than the declared variable length
			3. When assigning a number exceeds the declared precision or scale.
			
	4. INVALID_NUMBER
		- it is predefined exception 
		- error code: ORA-01722
		- It is raised when If we try to convert non-numeric value into number 
		
	5. DUP_VAL_ON_INDEX
		- it is predefined exception
		- error code: ORA-00001
		- It is raise when Unique constraint voilation
		  If we are inserting duplicate values in primary key column or unique key column 
		  
	6. ZERO_DIVIDE
		- it is predefined exception
		- error code: ORA-01476
		- When it is raise: If we are dividing a number by zero
		
	7. INVALID_CURSOR
		- it is predefined exception
		- error code: ORA-01001
		- it is raise : If we are trying to perform illegal operation
		  on cursor then we will get INVALID_CURSOR exception
		  
	8. CURSOR_ALREADY_OPEN
		- it is predefined exception
		- error code: ORA-06511
		- it is raise: If we are trying to open already opened cursor 
		  then we will get CURSOR_ALREADY_OPEN exception
	
	9. ROWTYPE_EXCEPTION
		- it is predefined exception 
		- error code: ORA-06504
		- when it raise: Incompatible %ROWTYPE
		  Happens when the number of column or data types in the SELECT statement
		  does not match the record 
		  
	10. PROGRAM_ERROR
		- it is predefined exception
		- error code: ORA-06501
		- it is occur due to PL/SQL engine problems 
		
	11. STORAGE_ERROR
		- It is prdefined exception
		- error code: ORA-06500
		- if there is memory allocation problem then we will get STORAGE_ERROR exception
		
	12. TIMEOUT_ON_RESOURCE
		- it is predefined exception
		- error code: ORA-00051
		- if request is not completed within required time then we will get TIMEOUT_ON_RESOURCE 
		
	13. LOGIN DENIED 
		- it is predefined exception
		- error code: ORA-01017
		- when it raise: invalid username or password 
		
	14. OTHERS
		- it is predefined exception
		- error code: NA 
		- Purpose: To catch all type of exceptions
------------------------------------
Q.. Non-Predefined exception?
==> The exception raise by oracle engine and have error code but do not have prdefined
    exception name are called Non-Predefined exception.
	- Properties
		1. Oracle raise automatically
		2. They don't have predefined name,but it has an error code 
		3. developer must have declare it and associate it with error code 
			using PRAGMA EXCEPTION_INIT
			
	- example of non-predefined exception
		1. trying to delete a parent row that has child rows 
		2. FOREGIN KEY constrain voilation
		3. table or view does not exist 
		4. unable to extent table 
------------------------------------
Q.. How to handle Non-Predefined exception?
==> we can handle Non-Predefined exception using 2 ways 
	1. using WHEN OTHERS 
	2. PRAGMA EXCEPTION_INIT
	
	1. using OTHERS 
		BEGIN
		 delete from department where dept_id=101;
		WHEN OTHERS THEN
			dbms_output.put_line('child record exist so can't delete parent table record');
		END;
		
	2. using PRAGMA EXCEPTION_INIT
		DECLARE
			fk_voilation EXCEPTION;
			PRAGMA EXCEPTION_INIT(fk_voilation,-2290);
		BEGIN
			delete from department where emp_id=101;
		EXCEPTION
			WHEN fk_voilation THEN 
				dbms_output.put_line('can't delete parent record ');
			WHEN OTHERS THEN 
				dbms_output.put_line('SQLERRM');
		END;
------------------------------------
Q.. What is PRAGMA EXCEPTION_INIT?
==> - it is compiler directive,not a statement 
	- it is used to associate a user declared exception name with oracle error code.
	- it is mainly used to handle non-predefined exception
	- some oracle error have only error code to give meaning full name those error 
	  codes we use PRAGMA EXCEPTION_INIT.
	- can't be used inside BEGIN section,we need to use in declare section.
------------------------------------
Q.. When to use PRAGMA EXCEPTION_INIT?
==> use PRAGMA EXCEPTION_INIT
	- error does not have predefined exception name
	- You know oracle error number 
	- You want specific handling 
	- You want clean,readable,maintainable code.
------------------------------------
Q.. difference between predefined and non-predefined exception?
==> - predefined exception have predefined name where as non-predefined excpetion don't have name 
	- predefined exception not require to declare where as non-predefined exception developer must declare
------------------------------------
Q.. WHEN to use WHEN OTHERS?
==> use WHEN OTHERS only when : 
	- You don't know exact error code 
	- You must to log or display the error message.
	- You want to ensure the program does not terminate abnormally
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------
------------------------------------